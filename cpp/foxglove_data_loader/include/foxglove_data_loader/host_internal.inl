// Modified from `host.c` generated by `wit-bindgen` 0.43.0.
#include <stdlib.h>
#include <string.h>

#include "host_internal.h"

// Imported Functions from `foxglove:loader/console@0.1.0`

__attribute__((__import_module__("foxglove:loader/console@0.1.0"), __import_name__("log"))
) extern void
__wasm_import_foxglove_loader_console_log(uint8_t*, size_t);

__attribute__((__import_module__("foxglove:loader/console@0.1.0"), __import_name__("error"))
) extern void
__wasm_import_foxglove_loader_console_error(uint8_t*, size_t);

__attribute__((__import_module__("foxglove:loader/console@0.1.0"), __import_name__("warn"))
) extern void
__wasm_import_foxglove_loader_console_warn(uint8_t*, size_t);

// Imported Functions from `foxglove:loader/reader@0.1.0`

__attribute__((
  __import_module__("foxglove:loader/reader@0.1.0"), __import_name__("[method]reader.seek")
)) extern int64_t
__wasm_import_foxglove_loader_reader_method_reader_seek(int32_t, int64_t);

__attribute__((
  __import_module__("foxglove:loader/reader@0.1.0"), __import_name__("[method]reader.position")
)) extern int64_t
__wasm_import_foxglove_loader_reader_method_reader_position(int32_t);

__attribute__((
  __import_module__("foxglove:loader/reader@0.1.0"), __import_name__("[method]reader.read")
)) extern int64_t
__wasm_import_foxglove_loader_reader_method_reader_read(int32_t, uint8_t*, size_t);

__attribute__((
  __import_module__("foxglove:loader/reader@0.1.0"), __import_name__("[method]reader.size")
)) extern int64_t
__wasm_import_foxglove_loader_reader_method_reader_size(int32_t);

__attribute__((__import_module__("foxglove:loader/reader@0.1.0"), __import_name__("open"))
) extern int32_t
__wasm_import_foxglove_loader_reader_open(uint8_t*, size_t);

// Exported Functions from `foxglove:loader/loader@0.1.0`

__attribute__((
  __weak__, __export_name__("cabi_post_foxglove:loader/loader@0.1.0#[method]message-iterator.next")
)) void
__wasm_export_exports_foxglove_loader_loader_method_message_iterator_next_post_return(uint8_t* arg0
) {
  switch ((int32_t)(int32_t)*((uint8_t*)(arg0 + 0))) {
    case 0: {
      break;
    }
    case 1: {
      switch ((int32_t)(int32_t)*((uint8_t*)(arg0 + 8))) {
        case 0: {
          // NOTE: the original generated `host.c` code calls free(ptr) on each message data
          // pointer, because the WIT component model ABI requires that all arguments and return
          // values are passed by copy. We're not adhering to the WIT component model here, and
          // the foxglove host wrapper code does not does not allocate a buffer for every message,
          // so we remove the corresponding free() here. The original code is left as comments for
          // reference.
          // size_t len = *((size_t*)(arg0 + (40 + 1 * sizeof(void*))));
          // if (len > 0) {
          //   uint8_t* ptr = *((uint8_t**)(arg0 + 40));
          //   for (size_t i = 0; i < len; i++) {
          //     uint8_t* base = ptr + i * 1;
          //     (void)base;
          //   }
          //   free(ptr);
          // }
          break;
        }
        case 1: {
          if ((*((size_t*)(arg0 + (16 + 1 * sizeof(void*))))) > 0) {
            free(*((uint8_t**)(arg0 + 16)));
          }
          break;
        }
      }
      break;
    }
  }
}

__attribute__((
  __weak__, __export_name__("cabi_post_foxglove:loader/loader@0.1.0#[method]data-loader.initialize")
)) void
__wasm_export_exports_foxglove_loader_loader_method_data_loader_initialize_post_return(uint8_t* arg0
) {
  switch ((int32_t)(int32_t)*((uint8_t*)(arg0 + 0))) {
    case 0: {
      size_t len = *((size_t*)(arg0 + (8 + 1 * sizeof(void*))));
      if (len > 0) {
        uint8_t* ptr = *((uint8_t**)(arg0 + 8));
        for (size_t i = 0; i < len; i++) {
          uint8_t* base = ptr + i * (24 + 4 * sizeof(void*));
          (void)base;
          if ((*((size_t*)(base + (8 + 1 * sizeof(void*))))) > 0) {
            free(*((uint8_t**)(base + 8)));
          }
          if ((*((size_t*)(base + (8 + 3 * sizeof(void*))))) > 0) {
            free(*((uint8_t**)(base + (8 + 2 * sizeof(void*)))));
          }
        }
        free(ptr);
      }
      size_t len3 = *((size_t*)(arg0 + (8 + 3 * sizeof(void*))));
      if (len3 > 0) {
        uint8_t* ptr4 = *((uint8_t**)(arg0 + (8 + 2 * sizeof(void*))));
        for (size_t i5 = 0; i5 < len3; i5++) {
          uint8_t* base = ptr4 + i5 * (7 * sizeof(void*));
          (void)base;
          if ((*((size_t*)(base + (2 * sizeof(void*))))) > 0) {
            free(*((uint8_t**)(base + sizeof(void*))));
          }
          if ((*((size_t*)(base + (4 * sizeof(void*))))) > 0) {
            free(*((uint8_t**)(base + (3 * sizeof(void*)))));
          }
          size_t len0 = *((size_t*)(base + (6 * sizeof(void*))));
          if (len0 > 0) {
            uint8_t* ptr1 = *((uint8_t**)(base + (5 * sizeof(void*))));
            for (size_t i2 = 0; i2 < len0; i2++) {
              uint8_t* base = ptr1 + i2 * 1;
              (void)base;
            }
            free(ptr1);
          }
        }
        free(ptr4);
      }
      size_t len6 = *((size_t*)(arg0 + (24 + 5 * sizeof(void*))));
      if (len6 > 0) {
        uint8_t* ptr7 = *((uint8_t**)(arg0 + (24 + 4 * sizeof(void*))));
        for (size_t i8 = 0; i8 < len6; i8++) {
          uint8_t* base = ptr7 + i8 * (6 * sizeof(void*));
          (void)base;
          if ((*((size_t*)(base + (2 * sizeof(void*))))) > 0) {
            free(*((uint8_t**)(base + sizeof(void*))));
          }
          switch ((int32_t)(int32_t)*((uint8_t*)(base + (3 * sizeof(void*))))) {
            case 0: {
              break;
            }
            case 1: {
              if ((*((size_t*)(base + (5 * sizeof(void*))))) > 0) {
                free(*((uint8_t**)(base + (4 * sizeof(void*)))));
              }
              break;
            }
          }
        }
        free(ptr7);
      }
      break;
    }
    case 1: {
      if ((*((size_t*)(arg0 + (8 + 1 * sizeof(void*))))) > 0) {
        free(*((uint8_t**)(arg0 + 8)));
      }
      break;
    }
  }
}

__attribute__((
  __weak__,
  __export_name__("cabi_post_foxglove:loader/loader@0.1.0#[method]data-loader.create-iterator")
)) void
__wasm_export_exports_foxglove_loader_loader_method_data_loader_create_iterator_post_return(
  uint8_t* arg0
) {
  switch ((int32_t)(int32_t)*((uint8_t*)(arg0 + 0))) {
    case 0: {
      break;
    }
    case 1: {
      if ((*((size_t*)(arg0 + (2 * sizeof(void*))))) > 0) {
        free(*((uint8_t**)(arg0 + sizeof(void*))));
      }
      break;
    }
  }
}

__attribute__((
  __weak__,
  __export_name__("cabi_post_foxglove:loader/loader@0.1.0#[method]data-loader.get-backfill")
)) void
__wasm_export_exports_foxglove_loader_loader_method_data_loader_get_backfill_post_return(
  uint8_t* arg0
) {
  switch ((int32_t)(int32_t)*((uint8_t*)(arg0 + 0))) {
    case 0: {
      size_t len0 = *((size_t*)(arg0 + (2 * sizeof(void*))));
      if (len0 > 0) {
        uint8_t* ptr1 = *((uint8_t**)(arg0 + sizeof(void*)));
        // NOTE: the original generated `host.c` code calls free(ptr) on each message data
        // pointer, because the WIT component model ABI requires that all arguments and return
        // values are passed by copy. We're not adhering to the WIT component model here, and
        // the foxglove host wrapper code does not does not allocate a buffer for every message,
        // so we remove the corresponding free() here. The original code is left as comments for
        // reference.
        // for (size_t i2 = 0; i2 < len0; i2++) {
        //   uint8_t* base = ptr1 + i2 * (24 + 2 * sizeof(void*));
        //   (void)base;
        //   size_t len = *((size_t*)(base + (24 + 1 * sizeof(void*))));
        //   if (len > 0) {
        //     uint8_t* ptr = *((uint8_t**)(base + 24));
        //     for (size_t i = 0; i < len; i++) {
        //       uint8_t* base = ptr + i * 1;
        //       (void)base;
        //     }
        //     free(ptr);
        //   }
        // }
        free(ptr1);
      }
      break;
    }
    case 1: {
      if ((*((size_t*)(arg0 + (2 * sizeof(void*))))) > 0) {
        free(*((uint8_t**)(arg0 + sizeof(void*))));
      }
      break;
    }
  }
}

// Canonical ABI intrinsics

__attribute__((__weak__, __export_name__("cabi_realloc"))) void* cabi_realloc(
  void* ptr, size_t old_size, size_t align, size_t new_size
) {
  (void)old_size;
  if (new_size == 0) return (void*)align;
  void* ret = realloc(ptr, new_size);
  if (!ret) abort();
  return ret;
}

__attribute__((__aligned__(8))) static uint8_t RET_AREA[(24 + 6 * sizeof(void*))];

// Helper Functions

__attribute__((
  __import_module__("foxglove:loader/reader@0.1.0"), __import_name__("[resource-drop]reader")
)) extern void
__wasm_import_foxglove_loader_reader_reader_drop(int32_t handle);

void foxglove_loader_reader_reader_drop_own(foxglove_loader_reader_own_reader_t handle) {
  __wasm_import_foxglove_loader_reader_reader_drop(handle.__handle);
}

void foxglove_loader_reader_reader_drop_borrow(foxglove_loader_reader_borrow_reader_t handle) {
  __wasm_import_foxglove_loader_reader_reader_drop(handle.__handle);
}

foxglove_loader_reader_borrow_reader_t foxglove_loader_reader_borrow_reader(
  foxglove_loader_reader_own_reader_t arg
) {
  return (foxglove_loader_reader_borrow_reader_t){arg.__handle};
}

void host_list_u8_free(host_list_u8_t* ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    uint8_t* list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
    }
    free(list_ptr);
  }
}

void exports_foxglove_loader_loader_error_free(exports_foxglove_loader_loader_error_t* ptr) {
  host_string_free(ptr);
}

void host_option_string_free(host_option_string_t* ptr) {
  if (ptr->is_some) {
    host_string_free(&ptr->val);
  }
}

void exports_foxglove_loader_loader_problem_free(exports_foxglove_loader_loader_problem_t* ptr) {
  host_string_free(&ptr->message);
  host_option_string_free(&ptr->tip);
}

void host_list_channel_id_free(host_list_channel_id_t* ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    exports_foxglove_loader_loader_channel_id_t* list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
    }
    free(list_ptr);
  }
}

void exports_foxglove_loader_loader_backfill_args_free(
  exports_foxglove_loader_loader_backfill_args_t* ptr
) {
  host_list_channel_id_free(&ptr->channels);
}

void host_option_time_nanos_free(host_option_time_nanos_t* ptr) {
  if (ptr->is_some) {
  }
}

void exports_foxglove_loader_loader_message_iterator_args_free(
  exports_foxglove_loader_loader_message_iterator_args_t* ptr
) {
  host_option_time_nanos_free(&ptr->start_time);
  host_option_time_nanos_free(&ptr->end_time);
  host_list_channel_id_free(&ptr->channels);
}

void host_option_schema_id_free(host_option_schema_id_t* ptr) {
  if (ptr->is_some) {
  }
}

void host_option_u64_free(host_option_u64_t* ptr) {
  if (ptr->is_some) {
  }
}

void exports_foxglove_loader_loader_channel_free(exports_foxglove_loader_loader_channel_t* ptr) {
  host_option_schema_id_free(&ptr->schema_id);
  host_string_free(&ptr->topic_name);
  host_string_free(&ptr->message_encoding);
  host_option_u64_free(&ptr->message_count);
}

void exports_foxglove_loader_loader_schema_free(exports_foxglove_loader_loader_schema_t* ptr) {
  host_string_free(&ptr->name);
  host_string_free(&ptr->encoding);
}

void exports_foxglove_loader_loader_list_channel_free(
  exports_foxglove_loader_loader_list_channel_t* ptr
) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    exports_foxglove_loader_loader_channel_t* list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      exports_foxglove_loader_loader_channel_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void exports_foxglove_loader_loader_list_schema_free(
  exports_foxglove_loader_loader_list_schema_t* ptr
) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    exports_foxglove_loader_loader_schema_t* list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      exports_foxglove_loader_loader_schema_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void exports_foxglove_loader_loader_list_problem_free(
  exports_foxglove_loader_loader_list_problem_t* ptr
) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    exports_foxglove_loader_loader_problem_t* list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      exports_foxglove_loader_loader_problem_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void exports_foxglove_loader_loader_initialization_free(
  exports_foxglove_loader_loader_initialization_t* ptr
) {
  exports_foxglove_loader_loader_list_channel_free(&ptr->channels);
  exports_foxglove_loader_loader_list_schema_free(&ptr->schemas);
  exports_foxglove_loader_loader_list_problem_free(&ptr->problems);
}

void host_list_string_free(host_list_string_t* ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    host_string_t* list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      host_string_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void exports_foxglove_loader_loader_data_loader_args_free(
  exports_foxglove_loader_loader_data_loader_args_t* ptr
) {
  host_list_string_free(&ptr->paths);
}

__attribute__((
  __import_module__("[export]foxglove:loader/loader@0.1.0"),
  __import_name__("[resource-drop]message-iterator")
)) extern void
__wasm_import_exports_foxglove_loader_loader_message_iterator_drop(int32_t handle);

void exports_foxglove_loader_loader_message_iterator_drop_own(
  exports_foxglove_loader_loader_own_message_iterator_t handle
) {
  __wasm_import_exports_foxglove_loader_loader_message_iterator_drop(handle.__handle);
}

__attribute__((
  __import_module__("[export]foxglove:loader/loader@0.1.0"),
  __import_name__("[resource-new]message-iterator")
)) extern int32_t
__wasm_import_exports_foxglove_loader_loader_message_iterator_new(int32_t);

__attribute__((
  __import_module__("[export]foxglove:loader/loader@0.1.0"),
  __import_name__("[resource-rep]message-iterator")
)) extern int32_t
__wasm_import_exports_foxglove_loader_loader_message_iterator_rep(int32_t);

exports_foxglove_loader_loader_own_message_iterator_t
exports_foxglove_loader_loader_message_iterator_new(
  exports_foxglove_loader_loader_message_iterator_t* rep
) {
  return (exports_foxglove_loader_loader_own_message_iterator_t
  ){__wasm_import_exports_foxglove_loader_loader_message_iterator_new((int32_t)rep)};
}

exports_foxglove_loader_loader_message_iterator_t*
exports_foxglove_loader_loader_message_iterator_rep(
  exports_foxglove_loader_loader_own_message_iterator_t handle
) {
  return (exports_foxglove_loader_loader_message_iterator_t*)
    __wasm_import_exports_foxglove_loader_loader_message_iterator_rep(handle.__handle);
}

// NOTE: wit-bindgen v0.43.0 has a bug that uses snake_case for the exported destructor name,
// which we've manually fixed here.
__attribute__((__export_name__("foxglove:loader/loader@0.1.0#[dtor]message-iterator"))) void
__wasm_export_exports_foxglove_loader_loader_message_iterator_dtor(
  exports_foxglove_loader_loader_message_iterator_t* arg
) {
  exports_foxglove_loader_loader_message_iterator_destructor(arg);
}

__attribute__((
  __import_module__("[export]foxglove:loader/loader@0.1.0"),
  __import_name__("[resource-drop]data-loader")
)) extern void
__wasm_import_exports_foxglove_loader_loader_data_loader_drop(int32_t handle);

void exports_foxglove_loader_loader_data_loader_drop_own(
  exports_foxglove_loader_loader_own_data_loader_t handle
) {
  __wasm_import_exports_foxglove_loader_loader_data_loader_drop(handle.__handle);
}

__attribute__((
  __import_module__("[export]foxglove:loader/loader@0.1.0"),
  __import_name__("[resource-new]data-loader")
)) extern int32_t
__wasm_import_exports_foxglove_loader_loader_data_loader_new(int32_t);

__attribute__((
  __import_module__("[export]foxglove:loader/loader@0.1.0"),
  __import_name__("[resource-rep]data-loader")
)) extern int32_t
__wasm_import_exports_foxglove_loader_loader_data_loader_rep(int32_t);

exports_foxglove_loader_loader_own_data_loader_t exports_foxglove_loader_loader_data_loader_new(
  exports_foxglove_loader_loader_data_loader_t* rep
) {
  return (exports_foxglove_loader_loader_own_data_loader_t
  ){__wasm_import_exports_foxglove_loader_loader_data_loader_new((int32_t)rep)};
}

exports_foxglove_loader_loader_data_loader_t* exports_foxglove_loader_loader_data_loader_rep(
  exports_foxglove_loader_loader_own_data_loader_t handle
) {
  return (exports_foxglove_loader_loader_data_loader_t*)
    __wasm_import_exports_foxglove_loader_loader_data_loader_rep(handle.__handle);
}

// NOTE: wit-bindgen v0.43.0 has a bug that uses snake_case for the exported destructor name,
// which we've manually fixed here.
__attribute__((__export_name__("foxglove:loader/loader@0.1.0#[dtor]data-loader"))) void
__wasm_export_exports_foxglove_loader_loader_data_loader_dtor(
  exports_foxglove_loader_loader_data_loader_t* arg
) {
  exports_foxglove_loader_loader_data_loader_destructor(arg);
}

void exports_foxglove_loader_loader_result_message_error_free(
  exports_foxglove_loader_loader_result_message_error_t* ptr
) {
  if (!ptr->is_err) {
  } else {
    exports_foxglove_loader_loader_error_free(&ptr->val.err);
  }
}

void exports_foxglove_loader_loader_option_result_message_error_free(
  exports_foxglove_loader_loader_option_result_message_error_t* ptr
) {
  if (ptr->is_some) {
    exports_foxglove_loader_loader_result_message_error_free(&ptr->val);
  }
}

void exports_foxglove_loader_loader_result_initialization_error_free(
  exports_foxglove_loader_loader_result_initialization_error_t* ptr
) {
  if (!ptr->is_err) {
    exports_foxglove_loader_loader_initialization_free(&ptr->val.ok);
  } else {
    exports_foxglove_loader_loader_error_free(&ptr->val.err);
  }
}

void exports_foxglove_loader_loader_result_own_message_iterator_error_free(
  exports_foxglove_loader_loader_result_own_message_iterator_error_t* ptr
) {
  if (!ptr->is_err) {
  } else {
    exports_foxglove_loader_loader_error_free(&ptr->val.err);
  }
}

void exports_foxglove_loader_loader_list_message_free(
  exports_foxglove_loader_loader_list_message_t* ptr
) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    exports_foxglove_loader_loader_message_t* list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
    }
    free(list_ptr);
  }
}

void exports_foxglove_loader_loader_result_list_message_error_free(
  exports_foxglove_loader_loader_result_list_message_error_t* ptr
) {
  if (!ptr->is_err) {
    exports_foxglove_loader_loader_list_message_free(&ptr->val.ok);
  } else {
    exports_foxglove_loader_loader_error_free(&ptr->val.err);
  }
}

void host_string_set(host_string_t* ret, const char* s) {
  ret->ptr = (uint8_t*)s;
  ret->len = strlen(s);
}

void host_string_clone(host_string_t* src, host_string_t* dst) {
  dst->len = src->len;
  dst->ptr = (uint8_t*)cabi_realloc(NULL, 0, 1, src->len);
  memcpy(dst->ptr, src->ptr, src->len);
}

void host_string_dup(host_string_t* ret, const char* s) {
  ret->len = strlen(s);
  ret->ptr = (uint8_t*)cabi_realloc(NULL, 0, 1, ret->len * 1);
  memcpy(ret->ptr, s, ret->len * 1);
}

void host_string_free(host_string_t* ret) {
  if (ret->len > 0) {
    free(ret->ptr);
  }
  ret->ptr = NULL;
  ret->len = 0;
}

// Component Adapters

void foxglove_loader_console_log(host_string_t* log) {
  __wasm_import_foxglove_loader_console_log((uint8_t*)(*log).ptr, (*log).len);
}

void foxglove_loader_console_error(host_string_t* log) {
  __wasm_import_foxglove_loader_console_error((uint8_t*)(*log).ptr, (*log).len);
}

void foxglove_loader_console_warn(host_string_t* log) {
  __wasm_import_foxglove_loader_console_warn((uint8_t*)(*log).ptr, (*log).len);
}

uint64_t foxglove_loader_reader_method_reader_seek(
  foxglove_loader_reader_borrow_reader_t self, uint64_t pos
) {
  int64_t ret =
    __wasm_import_foxglove_loader_reader_method_reader_seek((self).__handle, (int64_t)(pos));
  return (uint64_t)(ret);
}

uint64_t foxglove_loader_reader_method_reader_position(foxglove_loader_reader_borrow_reader_t self
) {
  int64_t ret = __wasm_import_foxglove_loader_reader_method_reader_position((self).__handle);
  return (uint64_t)(ret);
}

uint64_t foxglove_loader_reader_method_reader_read(
  foxglove_loader_reader_borrow_reader_t self, host_list_u8_t* target
) {
  int64_t ret = __wasm_import_foxglove_loader_reader_method_reader_read(
    (self).__handle, (uint8_t*)(*target).ptr, (*target).len
  );
  return (uint64_t)(ret);
}

uint64_t foxglove_loader_reader_method_reader_size(foxglove_loader_reader_borrow_reader_t self) {
  int64_t ret = __wasm_import_foxglove_loader_reader_method_reader_size((self).__handle);
  return (uint64_t)(ret);
}

foxglove_loader_reader_own_reader_t foxglove_loader_reader_open(host_string_t* path) {
  int32_t ret = __wasm_import_foxglove_loader_reader_open((uint8_t*)(*path).ptr, (*path).len);
  return (foxglove_loader_reader_own_reader_t){ret};
}

__attribute__((__export_name__("foxglove:loader/loader@0.1.0#[method]message-iterator.next")))
uint8_t*
__wasm_export_exports_foxglove_loader_loader_method_message_iterator_next(uint8_t* arg) {
  exports_foxglove_loader_loader_result_message_error_t val;
  bool ret = exports_foxglove_loader_loader_method_message_iterator_next(
    ((exports_foxglove_loader_loader_message_iterator_t*)arg), &val
  );

  exports_foxglove_loader_loader_option_result_message_error_t ret0;
  ret0.is_some = ret;
  ret0.val = val;
  uint8_t* ptr = (uint8_t*)&RET_AREA;
  if ((ret0).is_some) {
    const exports_foxglove_loader_loader_result_message_error_t* payload1 = &(ret0).val;
    *((int8_t*)(ptr + 0)) = 1;
    if ((*payload1).is_err) {
      const exports_foxglove_loader_loader_error_t* payload3 = &(*payload1).val.err;
      *((int8_t*)(ptr + 8)) = 1;
      *((size_t*)(ptr + (16 + 1 * sizeof(void*)))) = (*payload3).len;
      *((uint8_t**)(ptr + 16)) = (uint8_t*)(*payload3).ptr;
    } else {
      const exports_foxglove_loader_loader_message_t* payload2 = &(*payload1).val.ok;
      *((int8_t*)(ptr + 8)) = 0;
      *((int16_t*)(ptr + 16)) = (int32_t)((*payload2).channel_id);
      *((int64_t*)(ptr + 24)) = (int64_t)((*payload2).log_time);
      *((int64_t*)(ptr + 32)) = (int64_t)((*payload2).publish_time);
      *((size_t*)(ptr + (40 + 1 * sizeof(void*)))) = ((*payload2).data).len;
      *((uint8_t**)(ptr + 40)) = (uint8_t*)((*payload2).data).ptr;
    }
  } else {
    *((int8_t*)(ptr + 0)) = 0;
  }
  return ptr;
}

__attribute__((__export_name__("foxglove:loader/loader@0.1.0#[constructor]data-loader"))) int32_t
__wasm_export_exports_foxglove_loader_loader_constructor_data_loader(uint8_t* arg, size_t arg0) {
  exports_foxglove_loader_loader_data_loader_args_t arg1 =
    (exports_foxglove_loader_loader_data_loader_args_t){
      (host_list_string_t)(host_list_string_t){(host_string_t*)(arg), (arg0)},
    };
  exports_foxglove_loader_loader_own_data_loader_t ret =
    exports_foxglove_loader_loader_constructor_data_loader(&arg1);
  return (ret).__handle;
}

__attribute__((__export_name__("foxglove:loader/loader@0.1.0#[method]data-loader.initialize")))
uint8_t*
__wasm_export_exports_foxglove_loader_loader_method_data_loader_initialize(uint8_t* arg) {
  exports_foxglove_loader_loader_result_initialization_error_t ret;
  exports_foxglove_loader_loader_initialization_t ok;
  exports_foxglove_loader_loader_error_t err;
  ret.is_err = !exports_foxglove_loader_loader_method_data_loader_initialize(
    ((exports_foxglove_loader_loader_data_loader_t*)arg), &ok, &err
  );
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t* ptr = (uint8_t*)&RET_AREA;
  if ((ret).is_err) {
    const exports_foxglove_loader_loader_error_t* payload6 = &(ret).val.err;
    *((int8_t*)(ptr + 0)) = 1;
    *((size_t*)(ptr + (8 + 1 * sizeof(void*)))) = (*payload6).len;
    *((uint8_t**)(ptr + 8)) = (uint8_t*)(*payload6).ptr;
  } else {
    const exports_foxglove_loader_loader_initialization_t* payload = &(ret).val.ok;
    *((int8_t*)(ptr + 0)) = 0;
    *((size_t*)(ptr + (8 + 1 * sizeof(void*)))) = ((*payload).channels).len;
    *((uint8_t**)(ptr + 8)) = (uint8_t*)((*payload).channels).ptr;
    *((size_t*)(ptr + (8 + 3 * sizeof(void*)))) = ((*payload).schemas).len;
    *((uint8_t**)(ptr + (8 + 2 * sizeof(void*)))) = (uint8_t*)((*payload).schemas).ptr;
    *((int64_t*)(ptr + (8 + 4 * sizeof(void*)))) = (int64_t)(((*payload).time_range).start_time);
    *((int64_t*)(ptr + (16 + 4 * sizeof(void*)))) = (int64_t)(((*payload).time_range).end_time);
    *((size_t*)(ptr + (24 + 5 * sizeof(void*)))) = ((*payload).problems).len;
    *((uint8_t**)(ptr + (24 + 4 * sizeof(void*)))) = (uint8_t*)((*payload).problems).ptr;
  }
  return ptr;
}

__attribute__((__export_name__("foxglove:loader/loader@0.1.0#[method]data-loader.create-iterator")))
uint8_t*
__wasm_export_exports_foxglove_loader_loader_method_data_loader_create_iterator(
  uint8_t* arg, int32_t arg0, int64_t arg1, int32_t arg2, int64_t arg3, uint8_t* arg4, size_t arg5
) {
  host_option_time_nanos_t option;
  switch (arg0) {
    case 0: {
      option.is_some = false;
      break;
    }
    case 1: {
      option.is_some = true;
      option.val = (uint64_t)(arg1);
      break;
    }
  }
  host_option_time_nanos_t option6;
  switch (arg2) {
    case 0: {
      option6.is_some = false;
      break;
    }
    case 1: {
      option6.is_some = true;
      option6.val = (uint64_t)(arg3);
      break;
    }
  }
  exports_foxglove_loader_loader_message_iterator_args_t arg7 =
    (exports_foxglove_loader_loader_message_iterator_args_t){
      (host_option_time_nanos_t)option,
      (host_option_time_nanos_t)option6,
      (host_list_channel_id_t)(host_list_channel_id_t
      ){(exports_foxglove_loader_loader_channel_id_t*)(arg4), (arg5)},
    };
  exports_foxglove_loader_loader_result_own_message_iterator_error_t ret;
  exports_foxglove_loader_loader_own_message_iterator_t ok;
  exports_foxglove_loader_loader_error_t err;
  ret.is_err = !exports_foxglove_loader_loader_method_data_loader_create_iterator(
    ((exports_foxglove_loader_loader_data_loader_t*)arg), &arg7, &ok, &err
  );
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t* ptr = (uint8_t*)&RET_AREA;
  if ((ret).is_err) {
    const exports_foxglove_loader_loader_error_t* payload8 = &(ret).val.err;
    *((int8_t*)(ptr + 0)) = 1;
    *((size_t*)(ptr + (2 * sizeof(void*)))) = (*payload8).len;
    *((uint8_t**)(ptr + sizeof(void*))) = (uint8_t*)(*payload8).ptr;
  } else {
    const exports_foxglove_loader_loader_own_message_iterator_t* payload = &(ret).val.ok;
    *((int8_t*)(ptr + 0)) = 0;
    *((int32_t*)(ptr + sizeof(void*))) = (*payload).__handle;
  }
  return ptr;
}

__attribute__((__export_name__("foxglove:loader/loader@0.1.0#[method]data-loader.get-backfill")))
uint8_t*
__wasm_export_exports_foxglove_loader_loader_method_data_loader_get_backfill(
  uint8_t* arg, int64_t arg0, uint8_t* arg1, size_t arg2
) {
  exports_foxglove_loader_loader_backfill_args_t arg3 =
    (exports_foxglove_loader_loader_backfill_args_t){
      (exports_foxglove_loader_loader_time_nanos_t)(uint64_t)(arg0),
      (host_list_channel_id_t)(host_list_channel_id_t
      ){(exports_foxglove_loader_loader_channel_id_t*)(arg1), (arg2)},
    };
  exports_foxglove_loader_loader_result_list_message_error_t ret;
  exports_foxglove_loader_loader_list_message_t ok;
  exports_foxglove_loader_loader_error_t err;
  ret.is_err = !exports_foxglove_loader_loader_method_data_loader_get_backfill(
    ((exports_foxglove_loader_loader_data_loader_t*)arg), &arg3, &ok, &err
  );
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t* ptr = (uint8_t*)&RET_AREA;
  if ((ret).is_err) {
    const exports_foxglove_loader_loader_error_t* payload4 = &(ret).val.err;
    *((int8_t*)(ptr + 0)) = 1;
    *((size_t*)(ptr + (2 * sizeof(void*)))) = (*payload4).len;
    *((uint8_t**)(ptr + sizeof(void*))) = (uint8_t*)(*payload4).ptr;
  } else {
    const exports_foxglove_loader_loader_list_message_t* payload = &(ret).val.ok;
    *((int8_t*)(ptr + 0)) = 0;
    *((size_t*)(ptr + (2 * sizeof(void*)))) = (*payload).len;
    *((uint8_t**)(ptr + sizeof(void*))) = (uint8_t*)(*payload).ptr;
  }
  return ptr;
}

// Ensure that the *_component_type.o object is linked in

extern void __component_type_object_force_link_host(void);
void __component_type_object_force_link_host_public_use_in_this_compilation_unit(void) {
  __component_type_object_force_link_host();
}
