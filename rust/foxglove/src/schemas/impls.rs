// This file is @generated by foxglove_proto_gen
use crate::schemas::{descriptors, foxglove::*};
use crate::{Schema, Decode, Encode};
use bytes::BufMut;

impl Encode for ArrowPrimitive {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.ArrowPrimitive",
            "protobuf",
            descriptors::ARROW_PRIMITIVE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for ArrowPrimitive {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for CameraCalibration {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.CameraCalibration",
            "protobuf",
            descriptors::CAMERA_CALIBRATION,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for CameraCalibration {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for CircleAnnotation {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.CircleAnnotation",
            "protobuf",
            descriptors::CIRCLE_ANNOTATION,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for CircleAnnotation {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for Color {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Color",
            "protobuf",
            descriptors::COLOR,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Color {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for CompressedImage {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.CompressedImage",
            "protobuf",
            descriptors::COMPRESSED_IMAGE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for CompressedImage {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for CompressedVideo {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.CompressedVideo",
            "protobuf",
            descriptors::COMPRESSED_VIDEO,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for CompressedVideo {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for CubePrimitive {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.CubePrimitive",
            "protobuf",
            descriptors::CUBE_PRIMITIVE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for CubePrimitive {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for CylinderPrimitive {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.CylinderPrimitive",
            "protobuf",
            descriptors::CYLINDER_PRIMITIVE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for CylinderPrimitive {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for FrameTransform {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.FrameTransform",
            "protobuf",
            descriptors::FRAME_TRANSFORM,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for FrameTransform {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for FrameTransforms {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.FrameTransforms",
            "protobuf",
            descriptors::FRAME_TRANSFORMS,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for FrameTransforms {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for GeoJson {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.GeoJSON",
            "protobuf",
            descriptors::GEO_JSON,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for GeoJson {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for Grid {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Grid",
            "protobuf",
            descriptors::GRID,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Grid {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for ImageAnnotations {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.ImageAnnotations",
            "protobuf",
            descriptors::IMAGE_ANNOTATIONS,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for ImageAnnotations {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for KeyValuePair {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.KeyValuePair",
            "protobuf",
            descriptors::KEY_VALUE_PAIR,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for KeyValuePair {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for LaserScan {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.LaserScan",
            "protobuf",
            descriptors::LASER_SCAN,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for LaserScan {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for LinePrimitive {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.LinePrimitive",
            "protobuf",
            descriptors::LINE_PRIMITIVE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for LinePrimitive {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for LocationFix {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.LocationFix",
            "protobuf",
            descriptors::LOCATION_FIX,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for LocationFix {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for LocationFixes {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.LocationFixes",
            "protobuf",
            descriptors::LOCATION_FIXES,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for LocationFixes {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for Log {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Log",
            "protobuf",
            descriptors::LOG,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Log {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for ModelPrimitive {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.ModelPrimitive",
            "protobuf",
            descriptors::MODEL_PRIMITIVE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for ModelPrimitive {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for PackedElementField {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.PackedElementField",
            "protobuf",
            descriptors::PACKED_ELEMENT_FIELD,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for PackedElementField {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for Point2 {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Point2",
            "protobuf",
            descriptors::POINT2,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Point2 {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for Point3 {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Point3",
            "protobuf",
            descriptors::POINT3,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Point3 {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for PointCloud {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.PointCloud",
            "protobuf",
            descriptors::POINT_CLOUD,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for PointCloud {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for PointsAnnotation {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.PointsAnnotation",
            "protobuf",
            descriptors::POINTS_ANNOTATION,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for PointsAnnotation {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for Pose {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Pose",
            "protobuf",
            descriptors::POSE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Pose {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for PoseInFrame {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.PoseInFrame",
            "protobuf",
            descriptors::POSE_IN_FRAME,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for PoseInFrame {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for PosesInFrame {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.PosesInFrame",
            "protobuf",
            descriptors::POSES_IN_FRAME,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for PosesInFrame {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for Quaternion {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Quaternion",
            "protobuf",
            descriptors::QUATERNION,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Quaternion {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for RawAudio {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.RawAudio",
            "protobuf",
            descriptors::RAW_AUDIO,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for RawAudio {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for RawImage {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.RawImage",
            "protobuf",
            descriptors::RAW_IMAGE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for RawImage {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for SceneEntity {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.SceneEntity",
            "protobuf",
            descriptors::SCENE_ENTITY,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for SceneEntity {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for SceneEntityDeletion {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.SceneEntityDeletion",
            "protobuf",
            descriptors::SCENE_ENTITY_DELETION,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for SceneEntityDeletion {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for SceneUpdate {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.SceneUpdate",
            "protobuf",
            descriptors::SCENE_UPDATE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for SceneUpdate {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for SpherePrimitive {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.SpherePrimitive",
            "protobuf",
            descriptors::SPHERE_PRIMITIVE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for SpherePrimitive {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for TextAnnotation {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.TextAnnotation",
            "protobuf",
            descriptors::TEXT_ANNOTATION,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for TextAnnotation {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for TextPrimitive {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.TextPrimitive",
            "protobuf",
            descriptors::TEXT_PRIMITIVE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for TextPrimitive {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for TriangleListPrimitive {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.TriangleListPrimitive",
            "protobuf",
            descriptors::TRIANGLE_LIST_PRIMITIVE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for TriangleListPrimitive {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for Vector2 {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Vector2",
            "protobuf",
            descriptors::VECTOR2,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Vector2 {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for Vector3 {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Vector3",
            "protobuf",
            descriptors::VECTOR3,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Vector3 {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

impl Encode for VoxelGrid {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.VoxelGrid",
            "protobuf",
            descriptors::VOXEL_GRID,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for VoxelGrid {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}
