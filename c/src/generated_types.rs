// Generated by https://github.com/foxglove/foxglove-sdk

use std::ffi::c_uchar;
use std::mem::ManuallyDrop;
use std::pin::{pin, Pin};

use foxglove::Encode;

use crate::arena::{Arena, BorrowToNative};
use crate::util::{bytes_from_raw, string_from_raw, vec_from_raw};
#[cfg(not(target_family = "wasm"))]
use crate::{
    do_foxglove_channel_create, log_msg_to_channel, result_to_c, FoxgloveChannel, FoxgloveContext,
    FoxgloveSinkId,
};
use crate::{FoxgloveDuration, FoxgloveError, FoxgloveSchema, FoxgloveString, FoxgloveTimestamp};

#[derive(Clone, Copy, Debug)]
#[repr(i32)]
pub enum FoxgloveLineType {
    LineStrip = 0,
    LineLoop = 1,
    LineList = 2,
}

#[derive(Clone, Copy, Debug)]
#[repr(i32)]
pub enum FoxgloveLogLevel {
    Unknown = 0,
    Debug = 1,
    Info = 2,
    Warning = 3,
    Error = 4,
    Fatal = 5,
}

#[derive(Clone, Copy, Debug)]
#[repr(i32)]
pub enum FoxgloveSceneEntityDeletionType {
    MatchingId = 0,
    All = 1,
}

#[derive(Clone, Copy, Debug)]
#[repr(i32)]
pub enum FoxgloveNumericType {
    Unknown = 0,
    Uint8 = 1,
    Int8 = 2,
    Uint16 = 3,
    Int16 = 4,
    Uint32 = 5,
    Int32 = 6,
    Float32 = 7,
    Float64 = 8,
}

#[derive(Clone, Copy, Debug)]
#[repr(i32)]
pub enum FoxglovePointsAnnotationType {
    Unknown = 0,
    Points = 1,
    LineLoop = 2,
    LineStrip = 3,
    LineList = 4,
}

#[derive(Clone, Copy, Debug)]
#[repr(i32)]
pub enum FoxglovePositionCovarianceType {
    Unknown = 0,
    Approximated = 1,
    DiagonalKnown = 2,
    Known = 3,
}

/// A primitive representing an arrow
#[repr(C)]
pub struct ArrowPrimitive {
    /// Position of the arrow's tail and orientation of the arrow. Identity orientation means the arrow points in the +x direction.
    pub pose: *const Pose,

    /// Length of the arrow shaft
    pub shaft_length: f64,

    /// Diameter of the arrow shaft
    pub shaft_diameter: f64,

    /// Length of the arrow head
    pub head_length: f64,

    /// Diameter of the arrow head
    pub head_diameter: f64,

    /// Color of the arrow
    pub color: *const Color,
}

#[cfg(not(target_family = "wasm"))]
impl ArrowPrimitive {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_arrow_primitive(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::ArrowPrimitive>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for ArrowPrimitive {
    type NativeType = foxglove::schemas::ArrowPrimitive;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let pose = unsafe {
            self.pose
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let color = unsafe {
            self.color
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;

        Ok(ManuallyDrop::new(foxglove::schemas::ArrowPrimitive {
            pose: pose.map(ManuallyDrop::into_inner),
            shaft_length: self.shaft_length,
            shaft_diameter: self.shaft_diameter,
            head_length: self.head_length,
            head_diameter: self.head_diameter,
            color: color.map(ManuallyDrop::into_inner),
        }))
    }
}

/// Log a ArrowPrimitive message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_arrow_primitive.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_arrow_primitive(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&ArrowPrimitive>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { ArrowPrimitive::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("ArrowPrimitive: {}", e);
            e.into()
        }
    }
}

/// Get the ArrowPrimitive schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_arrow_primitive_schema() -> FoxgloveSchema {
    let native =
        foxglove::schemas::ArrowPrimitive::get_schema().expect("ArrowPrimitive schema is Some");
    let name: &'static str = "foxglove.ArrowPrimitive";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("ArrowPrimitive schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a ArrowPrimitive message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_arrow_primitive_encode(
    msg: Option<&ArrowPrimitive>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { ArrowPrimitive::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("ArrowPrimitive: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// Camera calibration parameters
#[repr(C)]
pub struct CameraCalibration {
    /// Timestamp of calibration data
    pub timestamp: *const FoxgloveTimestamp,

    /// Frame of reference for the camera. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
    pub frame_id: FoxgloveString,

    /// Image width
    pub width: u32,

    /// Image height
    pub height: u32,

    /// Name of distortion model
    ///
    /// Supported parameters: `plumb_bob` (k1, k2, p1, p2, k3), `rational_polynomial` (k1, k2, p1, p2, k3, k4, k5, k6), and `kannala_brandt` (k1, k2, k3, k4). `plumb_bob` and `rational_polynomial` models are based on the pinhole model [OpenCV's](https://docs.opencv.org/4.11.0/d9/d0c/group__calib3d.html) [pinhole camera model](https://en.wikipedia.org/wiki/Distortion_%28optics%29#Software_correction). The `kannala_brandt` model matches the [OpenvCV fisheye](https://docs.opencv.org/4.11.0/db/d58/group__calib3d__fisheye.html) model.
    pub distortion_model: FoxgloveString,

    /// Distortion parameters
    pub d: *const f64,
    pub d_count: usize,

    /// Intrinsic camera matrix (3x3 row-major matrix)
    ///
    /// A 3x3 row-major matrix for the raw (distorted) image.
    ///
    /// Projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal lengths (fx, fy) and principal point (cx, cy).
    ///
    /// ```
    ///     [fx  0 cx]
    /// K = [ 0 fy cy]
    ///     [ 0  0  1]
    /// ```
    ///
    pub k: [f64; 9],

    /// Rectification matrix (stereo cameras only, 3x3 row-major matrix)
    ///
    /// A rotation matrix aligning the camera coordinate system to the ideal stereo image plane so that epipolar lines in both stereo images are parallel.
    pub r: [f64; 9],

    /// Projection/camera matrix (3x4 row-major matrix)
    ///
    /// ```
    ///     [fx'  0  cx' Tx]
    /// P = [ 0  fy' cy' Ty]
    ///     [ 0   0   1   0]
    /// ```
    ///
    /// By convention, this matrix specifies the intrinsic (camera) matrix of the processed (rectified) image. That is, the left 3x3 portion is the normal camera intrinsic matrix for the rectified image.
    ///
    /// It projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal lengths (fx', fy') and principal point (cx', cy') - these may differ from the values in K.
    ///
    /// For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will also have R = the identity and P[1:3,1:3] = K.
    ///
    /// For a stereo pair, the fourth column [Tx Ty 0]' is related to the position of the optical center of the second camera in the first camera's frame. We assume Tz = 0 so both cameras are in the same stereo image plane. The first camera always has Tx = Ty = 0. For the right (second) camera of a horizontal stereo pair, Ty = 0 and Tx = -fx' * B, where B is the baseline between the cameras.
    ///
    /// Given a 3D point [X Y Z]', the projection (x, y) of the point onto the rectified image is given by:
    ///
    /// ```
    /// [u v w]' = P * [X Y Z 1]'
    ///        x = u / w
    ///        y = v / w
    /// ```
    ///
    /// This holds for both images of a stereo pair.
    ///
    pub p: [f64; 12],
}

#[cfg(not(target_family = "wasm"))]
impl CameraCalibration {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_camera_calibration(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::CameraCalibration>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for CameraCalibration {
    type NativeType = foxglove::schemas::CameraCalibration;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let frame_id = unsafe {
            string_from_raw(
                self.frame_id.as_ptr() as *const _,
                self.frame_id.len(),
                "frame_id",
            )?
        };
        let distortion_model = unsafe {
            string_from_raw(
                self.distortion_model.as_ptr() as *const _,
                self.distortion_model.len(),
                "distortion_model",
            )?
        };

        Ok(ManuallyDrop::new(foxglove::schemas::CameraCalibration {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            frame_id: ManuallyDrop::into_inner(frame_id),
            width: self.width,
            height: self.height,
            distortion_model: ManuallyDrop::into_inner(distortion_model),
            d: ManuallyDrop::into_inner(unsafe { vec_from_raw(self.d as *mut f64, self.d_count) }),
            k: ManuallyDrop::into_inner(unsafe {
                vec_from_raw(self.k.as_ptr() as *mut f64, self.k.len())
            }),
            r: ManuallyDrop::into_inner(unsafe {
                vec_from_raw(self.r.as_ptr() as *mut f64, self.r.len())
            }),
            p: ManuallyDrop::into_inner(unsafe {
                vec_from_raw(self.p.as_ptr() as *mut f64, self.p.len())
            }),
        }))
    }
}

/// Log a CameraCalibration message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_camera_calibration.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_camera_calibration(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&CameraCalibration>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { CameraCalibration::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("CameraCalibration: {}", e);
            e.into()
        }
    }
}

/// Get the CameraCalibration schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_camera_calibration_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::CameraCalibration::get_schema()
        .expect("CameraCalibration schema is Some");
    let name: &'static str = "foxglove.CameraCalibration";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("CameraCalibration schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a CameraCalibration message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_camera_calibration_encode(
    msg: Option<&CameraCalibration>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { CameraCalibration::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("CameraCalibration: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A circle annotation on a 2D image
#[repr(C)]
pub struct CircleAnnotation {
    /// Timestamp of circle
    pub timestamp: *const FoxgloveTimestamp,

    /// Center of the circle in 2D image coordinates (pixels).
    /// The coordinate uses the top-left corner of the top-left pixel of the image as the origin.
    pub position: *const Point2,

    /// Circle diameter in pixels
    pub diameter: f64,

    /// Line thickness in pixels
    pub thickness: f64,

    /// Fill color
    pub fill_color: *const Color,

    /// Outline color
    pub outline_color: *const Color,
}

#[cfg(not(target_family = "wasm"))]
impl CircleAnnotation {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_circle_annotation(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::CircleAnnotation>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for CircleAnnotation {
    type NativeType = foxglove::schemas::CircleAnnotation;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let position = unsafe {
            self.position
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let fill_color = unsafe {
            self.fill_color
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let outline_color = unsafe {
            self.outline_color
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;

        Ok(ManuallyDrop::new(foxglove::schemas::CircleAnnotation {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            position: position.map(ManuallyDrop::into_inner),
            diameter: self.diameter,
            thickness: self.thickness,
            fill_color: fill_color.map(ManuallyDrop::into_inner),
            outline_color: outline_color.map(ManuallyDrop::into_inner),
        }))
    }
}

/// Log a CircleAnnotation message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_circle_annotation.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_circle_annotation(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&CircleAnnotation>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { CircleAnnotation::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("CircleAnnotation: {}", e);
            e.into()
        }
    }
}

/// Get the CircleAnnotation schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_circle_annotation_schema() -> FoxgloveSchema {
    let native =
        foxglove::schemas::CircleAnnotation::get_schema().expect("CircleAnnotation schema is Some");
    let name: &'static str = "foxglove.CircleAnnotation";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("CircleAnnotation schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a CircleAnnotation message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_circle_annotation_encode(
    msg: Option<&CircleAnnotation>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { CircleAnnotation::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("CircleAnnotation: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A color in RGBA format
#[repr(C)]
pub struct Color {
    /// Red value between 0 and 1
    pub r: f64,

    /// Green value between 0 and 1
    pub g: f64,

    /// Blue value between 0 and 1
    pub b: f64,

    /// Alpha value between 0 and 1
    pub a: f64,
}

#[cfg(not(target_family = "wasm"))]
impl Color {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_color(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result = do_foxglove_channel_create::<foxglove::schemas::Color>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for Color {
    type NativeType = foxglove::schemas::Color;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        Ok(ManuallyDrop::new(foxglove::schemas::Color {
            r: self.r,
            g: self.g,
            b: self.b,
            a: self.a,
        }))
    }
}

/// Log a Color message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_color.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_color(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&Color>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { Color::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("Color: {}", e);
            e.into()
        }
    }
}

/// Get the Color schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_color_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::Color::get_schema().expect("Color schema is Some");
    let name: &'static str = "foxglove.Color";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("Color schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a Color message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_color_encode(
    msg: Option<&Color>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { Color::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("Color: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A compressed image
#[repr(C)]
pub struct CompressedImage {
    /// Timestamp of image
    pub timestamp: *const FoxgloveTimestamp,

    /// Frame of reference for the image. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
    pub frame_id: FoxgloveString,

    /// Compressed image data
    pub data: *const c_uchar,
    pub data_len: usize,

    /// Image format
    ///
    /// Supported values: `jpeg`, `png`, `webp`, `avif`
    pub format: FoxgloveString,
}

#[cfg(not(target_family = "wasm"))]
impl CompressedImage {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_compressed_image(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::CompressedImage>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for CompressedImage {
    type NativeType = foxglove::schemas::CompressedImage;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let frame_id = unsafe {
            string_from_raw(
                self.frame_id.as_ptr() as *const _,
                self.frame_id.len(),
                "frame_id",
            )?
        };
        let format = unsafe {
            string_from_raw(
                self.format.as_ptr() as *const _,
                self.format.len(),
                "format",
            )?
        };

        Ok(ManuallyDrop::new(foxglove::schemas::CompressedImage {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            frame_id: ManuallyDrop::into_inner(frame_id),
            data: ManuallyDrop::into_inner(unsafe { bytes_from_raw(self.data, self.data_len) }),
            format: ManuallyDrop::into_inner(format),
        }))
    }
}

/// Log a CompressedImage message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_compressed_image.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_compressed_image(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&CompressedImage>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { CompressedImage::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("CompressedImage: {}", e);
            e.into()
        }
    }
}

/// Get the CompressedImage schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_compressed_image_schema() -> FoxgloveSchema {
    let native =
        foxglove::schemas::CompressedImage::get_schema().expect("CompressedImage schema is Some");
    let name: &'static str = "foxglove.CompressedImage";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("CompressedImage schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a CompressedImage message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_compressed_image_encode(
    msg: Option<&CompressedImage>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { CompressedImage::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("CompressedImage: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A single frame of a compressed video bitstream
#[repr(C)]
pub struct CompressedVideo {
    /// Timestamp of video frame
    pub timestamp: *const FoxgloveTimestamp,

    /// Frame of reference for the video.
    ///
    /// The origin of the frame is the optical center of the camera. +x points to the right in the video, +y points down, and +z points into the plane of the video.
    pub frame_id: FoxgloveString,

    /// Compressed video frame data.
    ///
    /// For packet-based video codecs this data must begin and end on packet boundaries (no partial packets), and must contain enough video packets to decode exactly one image (either a keyframe or delta frame). Note: Foxglove does not support video streams that include B frames because they require lookahead.
    ///
    /// Specifically, the requirements for different `format` values are:
    ///
    /// - `h264`
    ///   - Use Annex B formatted data
    ///   - Each CompressedVideo message should contain enough NAL units to decode exactly one video frame
    ///   - Each message containing a key frame (IDR) must also include a SPS NAL unit
    ///
    /// - `h265` (HEVC)
    ///   - Use Annex B formatted data
    ///   - Each CompressedVideo message should contain enough NAL units to decode exactly one video frame
    ///   - Each message containing a key frame (IRAP) must also include relevant VPS/SPS/PPS NAL units
    ///
    /// - `vp9`
    ///   - Each CompressedVideo message should contain exactly one video frame
    ///
    /// - `av1`
    ///   - Use the "Low overhead bitstream format" (section 5.2)
    ///   - Each CompressedVideo message should contain enough OBUs to decode exactly one video frame
    ///   - Each message containing a key frame must also include a Sequence Header OBU
    pub data: *const c_uchar,
    pub data_len: usize,

    /// Video format.
    ///
    /// Supported values: `h264`, `h265`, `vp9`, `av1`.
    ///
    /// Note: compressed video support is subject to hardware limitations and patent licensing, so not all encodings may be supported on all platforms. See more about [H.265 support](https://caniuse.com/hevc), [VP9 support](https://caniuse.com/webm), and [AV1 support](https://caniuse.com/av1).
    pub format: FoxgloveString,
}

#[cfg(not(target_family = "wasm"))]
impl CompressedVideo {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_compressed_video(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::CompressedVideo>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for CompressedVideo {
    type NativeType = foxglove::schemas::CompressedVideo;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let frame_id = unsafe {
            string_from_raw(
                self.frame_id.as_ptr() as *const _,
                self.frame_id.len(),
                "frame_id",
            )?
        };
        let format = unsafe {
            string_from_raw(
                self.format.as_ptr() as *const _,
                self.format.len(),
                "format",
            )?
        };

        Ok(ManuallyDrop::new(foxglove::schemas::CompressedVideo {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            frame_id: ManuallyDrop::into_inner(frame_id),
            data: ManuallyDrop::into_inner(unsafe { bytes_from_raw(self.data, self.data_len) }),
            format: ManuallyDrop::into_inner(format),
        }))
    }
}

/// Log a CompressedVideo message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_compressed_video.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_compressed_video(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&CompressedVideo>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { CompressedVideo::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("CompressedVideo: {}", e);
            e.into()
        }
    }
}

/// Get the CompressedVideo schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_compressed_video_schema() -> FoxgloveSchema {
    let native =
        foxglove::schemas::CompressedVideo::get_schema().expect("CompressedVideo schema is Some");
    let name: &'static str = "foxglove.CompressedVideo";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("CompressedVideo schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a CompressedVideo message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_compressed_video_encode(
    msg: Option<&CompressedVideo>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { CompressedVideo::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("CompressedVideo: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A primitive representing a cylinder, elliptic cylinder, or truncated cone
#[repr(C)]
pub struct CylinderPrimitive {
    /// Position of the center of the cylinder and orientation of the cylinder. The flat face(s) are perpendicular to the z-axis.
    pub pose: *const Pose,

    /// Size of the cylinder's bounding box
    pub size: *const Vector3,

    /// 0-1, ratio of the diameter of the cylinder's bottom face (min z) to the bottom of the bounding box
    pub bottom_scale: f64,

    /// 0-1, ratio of the diameter of the cylinder's top face (max z) to the top of the bounding box
    pub top_scale: f64,

    /// Color of the cylinder
    pub color: *const Color,
}

#[cfg(not(target_family = "wasm"))]
impl CylinderPrimitive {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_cylinder_primitive(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::CylinderPrimitive>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for CylinderPrimitive {
    type NativeType = foxglove::schemas::CylinderPrimitive;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let pose = unsafe {
            self.pose
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let size = unsafe {
            self.size
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let color = unsafe {
            self.color
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;

        Ok(ManuallyDrop::new(foxglove::schemas::CylinderPrimitive {
            pose: pose.map(ManuallyDrop::into_inner),
            size: size.map(ManuallyDrop::into_inner),
            bottom_scale: self.bottom_scale,
            top_scale: self.top_scale,
            color: color.map(ManuallyDrop::into_inner),
        }))
    }
}

/// Log a CylinderPrimitive message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_cylinder_primitive.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_cylinder_primitive(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&CylinderPrimitive>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { CylinderPrimitive::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("CylinderPrimitive: {}", e);
            e.into()
        }
    }
}

/// Get the CylinderPrimitive schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_cylinder_primitive_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::CylinderPrimitive::get_schema()
        .expect("CylinderPrimitive schema is Some");
    let name: &'static str = "foxglove.CylinderPrimitive";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("CylinderPrimitive schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a CylinderPrimitive message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_cylinder_primitive_encode(
    msg: Option<&CylinderPrimitive>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { CylinderPrimitive::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("CylinderPrimitive: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A primitive representing a cube or rectangular prism
#[repr(C)]
pub struct CubePrimitive {
    /// Position of the center of the cube and orientation of the cube
    pub pose: *const Pose,

    /// Size of the cube along each axis
    pub size: *const Vector3,

    /// Color of the cube
    pub color: *const Color,
}

#[cfg(not(target_family = "wasm"))]
impl CubePrimitive {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_cube_primitive(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::CubePrimitive>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for CubePrimitive {
    type NativeType = foxglove::schemas::CubePrimitive;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let pose = unsafe {
            self.pose
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let size = unsafe {
            self.size
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let color = unsafe {
            self.color
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;

        Ok(ManuallyDrop::new(foxglove::schemas::CubePrimitive {
            pose: pose.map(ManuallyDrop::into_inner),
            size: size.map(ManuallyDrop::into_inner),
            color: color.map(ManuallyDrop::into_inner),
        }))
    }
}

/// Log a CubePrimitive message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_cube_primitive.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_cube_primitive(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&CubePrimitive>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { CubePrimitive::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("CubePrimitive: {}", e);
            e.into()
        }
    }
}

/// Get the CubePrimitive schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_cube_primitive_schema() -> FoxgloveSchema {
    let native =
        foxglove::schemas::CubePrimitive::get_schema().expect("CubePrimitive schema is Some");
    let name: &'static str = "foxglove.CubePrimitive";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("CubePrimitive schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a CubePrimitive message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_cube_primitive_encode(
    msg: Option<&CubePrimitive>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { CubePrimitive::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("CubePrimitive: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A transform between two reference frames in 3D space
#[repr(C)]
pub struct FrameTransform {
    /// Timestamp of transform
    pub timestamp: *const FoxgloveTimestamp,

    /// Name of the parent frame
    pub parent_frame_id: FoxgloveString,

    /// Name of the child frame
    pub child_frame_id: FoxgloveString,

    /// Translation component of the transform
    pub translation: *const Vector3,

    /// Rotation component of the transform
    pub rotation: *const Quaternion,
}

#[cfg(not(target_family = "wasm"))]
impl FrameTransform {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_frame_transform(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::FrameTransform>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for FrameTransform {
    type NativeType = foxglove::schemas::FrameTransform;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let parent_frame_id = unsafe {
            string_from_raw(
                self.parent_frame_id.as_ptr() as *const _,
                self.parent_frame_id.len(),
                "parent_frame_id",
            )?
        };
        let child_frame_id = unsafe {
            string_from_raw(
                self.child_frame_id.as_ptr() as *const _,
                self.child_frame_id.len(),
                "child_frame_id",
            )?
        };
        let translation = unsafe {
            self.translation
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let rotation = unsafe {
            self.rotation
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;

        Ok(ManuallyDrop::new(foxglove::schemas::FrameTransform {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            parent_frame_id: ManuallyDrop::into_inner(parent_frame_id),
            child_frame_id: ManuallyDrop::into_inner(child_frame_id),
            translation: translation.map(ManuallyDrop::into_inner),
            rotation: rotation.map(ManuallyDrop::into_inner),
        }))
    }
}

/// Log a FrameTransform message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_frame_transform.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_frame_transform(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&FrameTransform>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { FrameTransform::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("FrameTransform: {}", e);
            e.into()
        }
    }
}

/// Get the FrameTransform schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_frame_transform_schema() -> FoxgloveSchema {
    let native =
        foxglove::schemas::FrameTransform::get_schema().expect("FrameTransform schema is Some");
    let name: &'static str = "foxglove.FrameTransform";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("FrameTransform schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a FrameTransform message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_frame_transform_encode(
    msg: Option<&FrameTransform>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { FrameTransform::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("FrameTransform: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// An array of FrameTransform messages
#[repr(C)]
pub struct FrameTransforms {
    /// Array of transforms
    pub transforms: *const FrameTransform,
    pub transforms_count: usize,
}

#[cfg(not(target_family = "wasm"))]
impl FrameTransforms {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_frame_transforms(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::FrameTransforms>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for FrameTransforms {
    type NativeType = foxglove::schemas::FrameTransforms;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let transforms = unsafe { arena.as_mut().map(self.transforms, self.transforms_count)? };

        Ok(ManuallyDrop::new(foxglove::schemas::FrameTransforms {
            transforms: ManuallyDrop::into_inner(transforms),
        }))
    }
}

/// Log a FrameTransforms message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_frame_transforms.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_frame_transforms(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&FrameTransforms>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { FrameTransforms::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("FrameTransforms: {}", e);
            e.into()
        }
    }
}

/// Get the FrameTransforms schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_frame_transforms_schema() -> FoxgloveSchema {
    let native =
        foxglove::schemas::FrameTransforms::get_schema().expect("FrameTransforms schema is Some");
    let name: &'static str = "foxglove.FrameTransforms";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("FrameTransforms schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a FrameTransforms message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_frame_transforms_encode(
    msg: Option<&FrameTransforms>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { FrameTransforms::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("FrameTransforms: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// GeoJSON data for annotating maps
#[repr(C)]
pub struct GeoJson {
    /// GeoJSON data encoded as a UTF-8 string
    pub geojson: FoxgloveString,
}

#[cfg(not(target_family = "wasm"))]
impl GeoJson {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_geo_json(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result = do_foxglove_channel_create::<foxglove::schemas::GeoJson>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for GeoJson {
    type NativeType = foxglove::schemas::GeoJson;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let geojson = unsafe {
            string_from_raw(
                self.geojson.as_ptr() as *const _,
                self.geojson.len(),
                "geojson",
            )?
        };

        Ok(ManuallyDrop::new(foxglove::schemas::GeoJson {
            geojson: ManuallyDrop::into_inner(geojson),
        }))
    }
}

/// Log a GeoJson message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_geo_json.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_geo_json(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&GeoJson>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { GeoJson::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("GeoJson: {}", e);
            e.into()
        }
    }
}

/// Get the GeoJson schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_geo_json_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::GeoJson::get_schema().expect("GeoJson schema is Some");
    let name: &'static str = "foxglove.GeoJSON";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("GeoJson schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a GeoJson message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_geo_json_encode(
    msg: Option<&GeoJson>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { GeoJson::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("GeoJson: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A 2D grid of data
#[repr(C)]
pub struct Grid {
    /// Timestamp of grid
    pub timestamp: *const FoxgloveTimestamp,

    /// Frame of reference
    pub frame_id: FoxgloveString,

    /// Origin of grid's corner relative to frame of reference; grid is positioned in the x-y plane relative to this origin
    pub pose: *const Pose,

    /// Number of grid columns
    pub column_count: u32,

    /// Size of single grid cell along x and y axes, relative to `pose`
    pub cell_size: *const Vector2,

    /// Number of bytes between rows in `data`
    pub row_stride: u32,

    /// Number of bytes between cells within a row in `data`
    pub cell_stride: u32,

    /// Fields in `data`. `red`, `green`, `blue`, and `alpha` are optional for customizing the grid's color.
    pub fields: *const PackedElementField,
    pub fields_count: usize,

    /// Grid cell data, interpreted using `fields`, in row-major (y-major) order.
    ///  For the data element starting at byte offset i, the coordinates of its corner closest to the origin will be:
    ///  y = (i / cell_stride) % row_stride * cell_size.y
    ///  x = i % cell_stride * cell_size.x
    pub data: *const c_uchar,
    pub data_len: usize,
}

#[cfg(not(target_family = "wasm"))]
impl Grid {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_grid(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result = do_foxglove_channel_create::<foxglove::schemas::Grid>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for Grid {
    type NativeType = foxglove::schemas::Grid;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let frame_id = unsafe {
            string_from_raw(
                self.frame_id.as_ptr() as *const _,
                self.frame_id.len(),
                "frame_id",
            )?
        };
        let pose = unsafe {
            self.pose
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let cell_size = unsafe {
            self.cell_size
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let fields = unsafe { arena.as_mut().map(self.fields, self.fields_count)? };

        Ok(ManuallyDrop::new(foxglove::schemas::Grid {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            frame_id: ManuallyDrop::into_inner(frame_id),
            pose: pose.map(ManuallyDrop::into_inner),
            column_count: self.column_count,
            cell_size: cell_size.map(ManuallyDrop::into_inner),
            row_stride: self.row_stride,
            cell_stride: self.cell_stride,
            fields: ManuallyDrop::into_inner(fields),
            data: ManuallyDrop::into_inner(unsafe { bytes_from_raw(self.data, self.data_len) }),
        }))
    }
}

/// Log a Grid message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_grid.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_grid(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&Grid>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { Grid::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("Grid: {}", e);
            e.into()
        }
    }
}

/// Get the Grid schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_grid_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::Grid::get_schema().expect("Grid schema is Some");
    let name: &'static str = "foxglove.Grid";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("Grid schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a Grid message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_grid_encode(
    msg: Option<&Grid>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { Grid::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("Grid: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A 3D grid of data
#[repr(C)]
pub struct VoxelGrid {
    /// Timestamp of grid
    pub timestamp: *const FoxgloveTimestamp,

    /// Frame of reference
    pub frame_id: FoxgloveString,

    /// Origin of grid's corner relative to frame of reference
    pub pose: *const Pose,

    /// Number of grid rows
    pub row_count: u32,

    /// Number of grid columns
    pub column_count: u32,

    /// Size of single grid cell along x, y, and z axes, relative to `pose`
    pub cell_size: *const Vector3,

    /// Number of bytes between depth slices in `data`
    pub slice_stride: u32,

    /// Number of bytes between rows in `data`
    pub row_stride: u32,

    /// Number of bytes between cells within a row in `data`
    pub cell_stride: u32,

    /// Fields in `data`. `red`, `green`, `blue`, and `alpha` are optional for customizing the grid's color.
    pub fields: *const PackedElementField,
    pub fields_count: usize,

    /// Grid cell data, interpreted using `fields`, in depth-major, row-major (Z-Y-X) order.
    ///  For the data element starting at byte offset i, the coordinates of its corner closest to the origin will be:
    ///  z = i / slice_stride * cell_size.z
    ///  y = (i % slice_stride) / row_stride * cell_size.y
    ///  x = (i % row_stride) / cell_stride * cell_size.x
    pub data: *const c_uchar,
    pub data_len: usize,
}

#[cfg(not(target_family = "wasm"))]
impl VoxelGrid {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_voxel_grid(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result = do_foxglove_channel_create::<foxglove::schemas::VoxelGrid>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for VoxelGrid {
    type NativeType = foxglove::schemas::VoxelGrid;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let frame_id = unsafe {
            string_from_raw(
                self.frame_id.as_ptr() as *const _,
                self.frame_id.len(),
                "frame_id",
            )?
        };
        let pose = unsafe {
            self.pose
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let cell_size = unsafe {
            self.cell_size
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let fields = unsafe { arena.as_mut().map(self.fields, self.fields_count)? };

        Ok(ManuallyDrop::new(foxglove::schemas::VoxelGrid {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            frame_id: ManuallyDrop::into_inner(frame_id),
            pose: pose.map(ManuallyDrop::into_inner),
            row_count: self.row_count,
            column_count: self.column_count,
            cell_size: cell_size.map(ManuallyDrop::into_inner),
            slice_stride: self.slice_stride,
            row_stride: self.row_stride,
            cell_stride: self.cell_stride,
            fields: ManuallyDrop::into_inner(fields),
            data: ManuallyDrop::into_inner(unsafe { bytes_from_raw(self.data, self.data_len) }),
        }))
    }
}

/// Log a VoxelGrid message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_voxel_grid.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_voxel_grid(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&VoxelGrid>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { VoxelGrid::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("VoxelGrid: {}", e);
            e.into()
        }
    }
}

/// Get the VoxelGrid schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_voxel_grid_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::VoxelGrid::get_schema().expect("VoxelGrid schema is Some");
    let name: &'static str = "foxglove.VoxelGrid";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("VoxelGrid schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a VoxelGrid message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_voxel_grid_encode(
    msg: Option<&VoxelGrid>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { VoxelGrid::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("VoxelGrid: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// Array of annotations for a 2D image
#[repr(C)]
pub struct ImageAnnotations {
    /// Circle annotations
    pub circles: *const CircleAnnotation,
    pub circles_count: usize,

    /// Points annotations
    pub points: *const PointsAnnotation,
    pub points_count: usize,

    /// Text annotations
    pub texts: *const TextAnnotation,
    pub texts_count: usize,
}

#[cfg(not(target_family = "wasm"))]
impl ImageAnnotations {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_image_annotations(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::ImageAnnotations>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for ImageAnnotations {
    type NativeType = foxglove::schemas::ImageAnnotations;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let circles = unsafe { arena.as_mut().map(self.circles, self.circles_count)? };
        let points = unsafe { arena.as_mut().map(self.points, self.points_count)? };
        let texts = unsafe { arena.as_mut().map(self.texts, self.texts_count)? };

        Ok(ManuallyDrop::new(foxglove::schemas::ImageAnnotations {
            circles: ManuallyDrop::into_inner(circles),
            points: ManuallyDrop::into_inner(points),
            texts: ManuallyDrop::into_inner(texts),
        }))
    }
}

/// Log a ImageAnnotations message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_image_annotations.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_image_annotations(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&ImageAnnotations>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { ImageAnnotations::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("ImageAnnotations: {}", e);
            e.into()
        }
    }
}

/// Get the ImageAnnotations schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_image_annotations_schema() -> FoxgloveSchema {
    let native =
        foxglove::schemas::ImageAnnotations::get_schema().expect("ImageAnnotations schema is Some");
    let name: &'static str = "foxglove.ImageAnnotations";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("ImageAnnotations schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a ImageAnnotations message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_image_annotations_encode(
    msg: Option<&ImageAnnotations>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { ImageAnnotations::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("ImageAnnotations: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A key with its associated value
#[repr(C)]
pub struct KeyValuePair {
    /// Key
    pub key: FoxgloveString,

    /// Value
    pub value: FoxgloveString,
}

#[cfg(not(target_family = "wasm"))]
impl KeyValuePair {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_key_value_pair(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::KeyValuePair>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for KeyValuePair {
    type NativeType = foxglove::schemas::KeyValuePair;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let key = unsafe { string_from_raw(self.key.as_ptr() as *const _, self.key.len(), "key")? };
        let value =
            unsafe { string_from_raw(self.value.as_ptr() as *const _, self.value.len(), "value")? };

        Ok(ManuallyDrop::new(foxglove::schemas::KeyValuePair {
            key: ManuallyDrop::into_inner(key),
            value: ManuallyDrop::into_inner(value),
        }))
    }
}

/// Log a KeyValuePair message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_key_value_pair.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_key_value_pair(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&KeyValuePair>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { KeyValuePair::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("KeyValuePair: {}", e);
            e.into()
        }
    }
}

/// Get the KeyValuePair schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_key_value_pair_schema() -> FoxgloveSchema {
    let native =
        foxglove::schemas::KeyValuePair::get_schema().expect("KeyValuePair schema is Some");
    let name: &'static str = "foxglove.KeyValuePair";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("KeyValuePair schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a KeyValuePair message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_key_value_pair_encode(
    msg: Option<&KeyValuePair>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { KeyValuePair::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("KeyValuePair: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A single scan from a planar laser range-finder
#[repr(C)]
pub struct LaserScan {
    /// Timestamp of scan
    pub timestamp: *const FoxgloveTimestamp,

    /// Frame of reference
    pub frame_id: FoxgloveString,

    /// Origin of scan relative to frame of reference; points are positioned in the x-y plane relative to this origin; angles are interpreted as counterclockwise rotations around the z axis with 0 rad being in the +x direction
    pub pose: *const Pose,

    /// Bearing of first point, in radians
    pub start_angle: f64,

    /// Bearing of last point, in radians
    pub end_angle: f64,

    /// Distance of detections from origin; assumed to be at equally-spaced angles between `start_angle` and `end_angle`
    pub ranges: *const f64,
    pub ranges_count: usize,

    /// Intensity of detections
    pub intensities: *const f64,
    pub intensities_count: usize,
}

#[cfg(not(target_family = "wasm"))]
impl LaserScan {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_laser_scan(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result = do_foxglove_channel_create::<foxglove::schemas::LaserScan>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for LaserScan {
    type NativeType = foxglove::schemas::LaserScan;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let frame_id = unsafe {
            string_from_raw(
                self.frame_id.as_ptr() as *const _,
                self.frame_id.len(),
                "frame_id",
            )?
        };
        let pose = unsafe {
            self.pose
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;

        Ok(ManuallyDrop::new(foxglove::schemas::LaserScan {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            frame_id: ManuallyDrop::into_inner(frame_id),
            pose: pose.map(ManuallyDrop::into_inner),
            start_angle: self.start_angle,
            end_angle: self.end_angle,
            ranges: ManuallyDrop::into_inner(unsafe {
                vec_from_raw(self.ranges as *mut f64, self.ranges_count)
            }),
            intensities: ManuallyDrop::into_inner(unsafe {
                vec_from_raw(self.intensities as *mut f64, self.intensities_count)
            }),
        }))
    }
}

/// Log a LaserScan message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_laser_scan.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_laser_scan(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&LaserScan>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { LaserScan::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("LaserScan: {}", e);
            e.into()
        }
    }
}

/// Get the LaserScan schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_laser_scan_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::LaserScan::get_schema().expect("LaserScan schema is Some");
    let name: &'static str = "foxglove.LaserScan";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("LaserScan schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a LaserScan message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_laser_scan_encode(
    msg: Option<&LaserScan>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { LaserScan::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("LaserScan: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A primitive representing a series of points connected by lines
#[repr(C)]
pub struct LinePrimitive {
    /// Drawing primitive to use for lines
    pub r#type: FoxgloveLineType,

    /// Origin of lines relative to reference frame
    pub pose: *const Pose,

    /// Line thickness
    pub thickness: f64,

    /// Indicates whether `thickness` is a fixed size in screen pixels (true), or specified in world coordinates and scales with distance from the camera (false)
    pub scale_invariant: bool,

    /// Points along the line
    pub points: *const Point3,
    pub points_count: usize,

    /// Solid color to use for the whole line. One of `color` or `colors` must be provided.
    pub color: *const Color,

    /// Per-point colors (if specified, must have the same length as `points`). One of `color` or `colors` must be provided.
    pub colors: *const Color,
    pub colors_count: usize,

    /// Indices into the `points` and `colors` attribute arrays, which can be used to avoid duplicating attribute data.
    ///
    /// If omitted or empty, indexing will not be used. This default behavior is equivalent to specifying [0, 1, ..., N-1] for the indices (where N is the number of `points` provided).
    pub indices: *const u32,
    pub indices_count: usize,
}

#[cfg(not(target_family = "wasm"))]
impl LinePrimitive {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_line_primitive(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::LinePrimitive>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for LinePrimitive {
    type NativeType = foxglove::schemas::LinePrimitive;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let pose = unsafe {
            self.pose
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let points = unsafe { arena.as_mut().map(self.points, self.points_count)? };
        let color = unsafe {
            self.color
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let colors = unsafe { arena.as_mut().map(self.colors, self.colors_count)? };

        Ok(ManuallyDrop::new(foxglove::schemas::LinePrimitive {
            r#type: self.r#type as i32,
            pose: pose.map(ManuallyDrop::into_inner),
            thickness: self.thickness,
            scale_invariant: self.scale_invariant,
            points: ManuallyDrop::into_inner(points),
            color: color.map(ManuallyDrop::into_inner),
            colors: ManuallyDrop::into_inner(colors),
            indices: ManuallyDrop::into_inner(unsafe {
                vec_from_raw(self.indices as *mut u32, self.indices_count)
            }),
        }))
    }
}

/// Log a LinePrimitive message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_line_primitive.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_line_primitive(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&LinePrimitive>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { LinePrimitive::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("LinePrimitive: {}", e);
            e.into()
        }
    }
}

/// Get the LinePrimitive schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_line_primitive_schema() -> FoxgloveSchema {
    let native =
        foxglove::schemas::LinePrimitive::get_schema().expect("LinePrimitive schema is Some");
    let name: &'static str = "foxglove.LinePrimitive";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("LinePrimitive schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a LinePrimitive message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_line_primitive_encode(
    msg: Option<&LinePrimitive>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { LinePrimitive::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("LinePrimitive: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A navigation satellite fix for any Global Navigation Satellite System
#[repr(C)]
pub struct LocationFix {
    /// Timestamp of the message
    pub timestamp: *const FoxgloveTimestamp,

    /// Frame for the sensor. Latitude and longitude readings are at the origin of the frame.
    pub frame_id: FoxgloveString,

    /// Latitude in degrees
    pub latitude: f64,

    /// Longitude in degrees
    pub longitude: f64,

    /// Altitude in meters
    pub altitude: f64,

    /// Position covariance (m^2) defined relative to a tangential plane through the reported position. The components are East, North, and Up (ENU), in row-major order.
    pub position_covariance: [f64; 9],

    /// If `position_covariance` is available, `position_covariance_type` must be set to indicate the type of covariance.
    pub position_covariance_type: FoxglovePositionCovarianceType,

    /// Color used to visualize the location
    pub color: *const Color,
}

#[cfg(not(target_family = "wasm"))]
impl LocationFix {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_location_fix(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::LocationFix>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for LocationFix {
    type NativeType = foxglove::schemas::LocationFix;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let frame_id = unsafe {
            string_from_raw(
                self.frame_id.as_ptr() as *const _,
                self.frame_id.len(),
                "frame_id",
            )?
        };
        let color = unsafe {
            self.color
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;

        Ok(ManuallyDrop::new(foxglove::schemas::LocationFix {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            frame_id: ManuallyDrop::into_inner(frame_id),
            latitude: self.latitude,
            longitude: self.longitude,
            altitude: self.altitude,
            position_covariance: ManuallyDrop::into_inner(unsafe {
                vec_from_raw(
                    self.position_covariance.as_ptr() as *mut f64,
                    self.position_covariance.len(),
                )
            }),
            position_covariance_type: self.position_covariance_type as i32,
            color: color.map(ManuallyDrop::into_inner),
        }))
    }
}

/// Log a LocationFix message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_location_fix.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_location_fix(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&LocationFix>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { LocationFix::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("LocationFix: {}", e);
            e.into()
        }
    }
}

/// Get the LocationFix schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_location_fix_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::LocationFix::get_schema().expect("LocationFix schema is Some");
    let name: &'static str = "foxglove.LocationFix";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("LocationFix schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a LocationFix message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_location_fix_encode(
    msg: Option<&LocationFix>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { LocationFix::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("LocationFix: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A group of LocationFix messages
#[repr(C)]
pub struct LocationFixes {
    /// An array of location fixes
    pub fixes: *const LocationFix,
    pub fixes_count: usize,
}

#[cfg(not(target_family = "wasm"))]
impl LocationFixes {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_location_fixes(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::LocationFixes>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for LocationFixes {
    type NativeType = foxglove::schemas::LocationFixes;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let fixes = unsafe { arena.as_mut().map(self.fixes, self.fixes_count)? };

        Ok(ManuallyDrop::new(foxglove::schemas::LocationFixes {
            fixes: ManuallyDrop::into_inner(fixes),
        }))
    }
}

/// Log a LocationFixes message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_location_fixes.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_location_fixes(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&LocationFixes>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { LocationFixes::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("LocationFixes: {}", e);
            e.into()
        }
    }
}

/// Get the LocationFixes schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_location_fixes_schema() -> FoxgloveSchema {
    let native =
        foxglove::schemas::LocationFixes::get_schema().expect("LocationFixes schema is Some");
    let name: &'static str = "foxglove.LocationFixes";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("LocationFixes schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a LocationFixes message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_location_fixes_encode(
    msg: Option<&LocationFixes>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { LocationFixes::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("LocationFixes: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A log message
#[repr(C)]
pub struct Log {
    /// Timestamp of log message
    pub timestamp: *const FoxgloveTimestamp,

    /// Log level
    pub level: FoxgloveLogLevel,

    /// Log message
    pub message: FoxgloveString,

    /// Process or node name
    pub name: FoxgloveString,

    /// Filename
    pub file: FoxgloveString,

    /// Line number in the file
    pub line: u32,
}

#[cfg(not(target_family = "wasm"))]
impl Log {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_log(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result = do_foxglove_channel_create::<foxglove::schemas::Log>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for Log {
    type NativeType = foxglove::schemas::Log;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let message = unsafe {
            string_from_raw(
                self.message.as_ptr() as *const _,
                self.message.len(),
                "message",
            )?
        };
        let name =
            unsafe { string_from_raw(self.name.as_ptr() as *const _, self.name.len(), "name")? };
        let file =
            unsafe { string_from_raw(self.file.as_ptr() as *const _, self.file.len(), "file")? };

        Ok(ManuallyDrop::new(foxglove::schemas::Log {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            level: self.level as i32,
            message: ManuallyDrop::into_inner(message),
            name: ManuallyDrop::into_inner(name),
            file: ManuallyDrop::into_inner(file),
            line: self.line,
        }))
    }
}

/// Log a Log message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_log.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_log(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&Log>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { Log::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("Log: {}", e);
            e.into()
        }
    }
}

/// Get the Log schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_log_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::Log::get_schema().expect("Log schema is Some");
    let name: &'static str = "foxglove.Log";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("Log schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a Log message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_log_encode(
    msg: Option<&Log>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { Log::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("Log: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// Command to remove previously published entities
#[repr(C)]
pub struct SceneEntityDeletion {
    /// Timestamp of the deletion. Only matching entities earlier than this timestamp will be deleted.
    pub timestamp: *const FoxgloveTimestamp,

    /// Type of deletion action to perform
    pub r#type: FoxgloveSceneEntityDeletionType,

    /// Identifier which must match if `type` is `MATCHING_ID`.
    pub id: FoxgloveString,
}

#[cfg(not(target_family = "wasm"))]
impl SceneEntityDeletion {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_scene_entity_deletion(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result = do_foxglove_channel_create::<foxglove::schemas::SceneEntityDeletion>(
                topic, context,
            );
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for SceneEntityDeletion {
    type NativeType = foxglove::schemas::SceneEntityDeletion;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let id = unsafe { string_from_raw(self.id.as_ptr() as *const _, self.id.len(), "id")? };

        Ok(ManuallyDrop::new(foxglove::schemas::SceneEntityDeletion {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            r#type: self.r#type as i32,
            id: ManuallyDrop::into_inner(id),
        }))
    }
}

/// Log a SceneEntityDeletion message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_scene_entity_deletion.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_scene_entity_deletion(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&SceneEntityDeletion>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { SceneEntityDeletion::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("SceneEntityDeletion: {}", e);
            e.into()
        }
    }
}

/// Get the SceneEntityDeletion schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_scene_entity_deletion_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::SceneEntityDeletion::get_schema()
        .expect("SceneEntityDeletion schema is Some");
    let name: &'static str = "foxglove.SceneEntityDeletion";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("SceneEntityDeletion schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a SceneEntityDeletion message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_scene_entity_deletion_encode(
    msg: Option<&SceneEntityDeletion>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { SceneEntityDeletion::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("SceneEntityDeletion: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A visual element in a 3D scene. An entity may be composed of multiple primitives which all share the same frame of reference.
#[repr(C)]
pub struct SceneEntity {
    /// Timestamp of the entity
    pub timestamp: *const FoxgloveTimestamp,

    /// Frame of reference
    pub frame_id: FoxgloveString,

    /// Identifier for the entity. A entity will replace any prior entity on the same topic with the same `id`.
    pub id: FoxgloveString,

    /// Length of time (relative to `timestamp`) after which the entity should be automatically removed. Zero value indicates the entity should remain visible until it is replaced or deleted.
    pub lifetime: *const FoxgloveDuration,

    /// Whether the entity should keep its location in the fixed frame (false) or follow the frame specified in `frame_id` as it moves relative to the fixed frame (true)
    pub frame_locked: bool,

    /// Additional user-provided metadata associated with the entity. Keys must be unique.
    pub metadata: *const KeyValuePair,
    pub metadata_count: usize,

    /// Arrow primitives
    pub arrows: *const ArrowPrimitive,
    pub arrows_count: usize,

    /// Cube primitives
    pub cubes: *const CubePrimitive,
    pub cubes_count: usize,

    /// Sphere primitives
    pub spheres: *const SpherePrimitive,
    pub spheres_count: usize,

    /// Cylinder primitives
    pub cylinders: *const CylinderPrimitive,
    pub cylinders_count: usize,

    /// Line primitives
    pub lines: *const LinePrimitive,
    pub lines_count: usize,

    /// Triangle list primitives
    pub triangles: *const TriangleListPrimitive,
    pub triangles_count: usize,

    /// Text primitives
    pub texts: *const TextPrimitive,
    pub texts_count: usize,

    /// Model primitives
    pub models: *const ModelPrimitive,
    pub models_count: usize,
}

#[cfg(not(target_family = "wasm"))]
impl SceneEntity {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_scene_entity(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::SceneEntity>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for SceneEntity {
    type NativeType = foxglove::schemas::SceneEntity;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let frame_id = unsafe {
            string_from_raw(
                self.frame_id.as_ptr() as *const _,
                self.frame_id.len(),
                "frame_id",
            )?
        };
        let id = unsafe { string_from_raw(self.id.as_ptr() as *const _, self.id.len(), "id")? };
        let metadata = unsafe { arena.as_mut().map(self.metadata, self.metadata_count)? };
        let arrows = unsafe { arena.as_mut().map(self.arrows, self.arrows_count)? };
        let cubes = unsafe { arena.as_mut().map(self.cubes, self.cubes_count)? };
        let spheres = unsafe { arena.as_mut().map(self.spheres, self.spheres_count)? };
        let cylinders = unsafe { arena.as_mut().map(self.cylinders, self.cylinders_count)? };
        let lines = unsafe { arena.as_mut().map(self.lines, self.lines_count)? };
        let triangles = unsafe { arena.as_mut().map(self.triangles, self.triangles_count)? };
        let texts = unsafe { arena.as_mut().map(self.texts, self.texts_count)? };
        let models = unsafe { arena.as_mut().map(self.models, self.models_count)? };

        Ok(ManuallyDrop::new(foxglove::schemas::SceneEntity {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            frame_id: ManuallyDrop::into_inner(frame_id),
            id: ManuallyDrop::into_inner(id),
            lifetime: unsafe { self.lifetime.as_ref() }.map(|&m| m.into()),
            frame_locked: self.frame_locked,
            metadata: ManuallyDrop::into_inner(metadata),
            arrows: ManuallyDrop::into_inner(arrows),
            cubes: ManuallyDrop::into_inner(cubes),
            spheres: ManuallyDrop::into_inner(spheres),
            cylinders: ManuallyDrop::into_inner(cylinders),
            lines: ManuallyDrop::into_inner(lines),
            triangles: ManuallyDrop::into_inner(triangles),
            texts: ManuallyDrop::into_inner(texts),
            models: ManuallyDrop::into_inner(models),
        }))
    }
}

/// Log a SceneEntity message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_scene_entity.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_scene_entity(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&SceneEntity>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { SceneEntity::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("SceneEntity: {}", e);
            e.into()
        }
    }
}

/// Get the SceneEntity schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_scene_entity_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::SceneEntity::get_schema().expect("SceneEntity schema is Some");
    let name: &'static str = "foxglove.SceneEntity";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("SceneEntity schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a SceneEntity message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_scene_entity_encode(
    msg: Option<&SceneEntity>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { SceneEntity::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("SceneEntity: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// An update to the entities displayed in a 3D scene
#[repr(C)]
pub struct SceneUpdate {
    /// Scene entities to delete
    pub deletions: *const SceneEntityDeletion,
    pub deletions_count: usize,

    /// Scene entities to add or replace
    pub entities: *const SceneEntity,
    pub entities_count: usize,
}

#[cfg(not(target_family = "wasm"))]
impl SceneUpdate {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_scene_update(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::SceneUpdate>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for SceneUpdate {
    type NativeType = foxglove::schemas::SceneUpdate;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let deletions = unsafe { arena.as_mut().map(self.deletions, self.deletions_count)? };
        let entities = unsafe { arena.as_mut().map(self.entities, self.entities_count)? };

        Ok(ManuallyDrop::new(foxglove::schemas::SceneUpdate {
            deletions: ManuallyDrop::into_inner(deletions),
            entities: ManuallyDrop::into_inner(entities),
        }))
    }
}

/// Log a SceneUpdate message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_scene_update.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_scene_update(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&SceneUpdate>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { SceneUpdate::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("SceneUpdate: {}", e);
            e.into()
        }
    }
}

/// Get the SceneUpdate schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_scene_update_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::SceneUpdate::get_schema().expect("SceneUpdate schema is Some");
    let name: &'static str = "foxglove.SceneUpdate";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("SceneUpdate schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a SceneUpdate message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_scene_update_encode(
    msg: Option<&SceneUpdate>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { SceneUpdate::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("SceneUpdate: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A primitive representing a 3D model file loaded from an external URL or embedded data
#[repr(C)]
pub struct ModelPrimitive {
    /// Origin of model relative to reference frame
    pub pose: *const Pose,

    /// Scale factor to apply to the model along each axis
    pub scale: *const Vector3,

    /// Solid color to use for the whole model if `override_color` is true.
    pub color: *const Color,

    /// Whether to use the color specified in `color` instead of any materials embedded in the original model.
    pub override_color: bool,

    /// URL pointing to model file. One of `url` or `data` should be provided.
    pub url: FoxgloveString,

    /// [Media type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) of embedded model (e.g. `model/gltf-binary`). Required if `data` is provided instead of `url`. Overrides the inferred media type if `url` is provided.
    pub media_type: FoxgloveString,

    /// Embedded model. One of `url` or `data` should be provided. If `data` is provided, `media_type` must be set to indicate the type of the data.
    pub data: *const c_uchar,
    pub data_len: usize,
}

#[cfg(not(target_family = "wasm"))]
impl ModelPrimitive {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_model_primitive(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::ModelPrimitive>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for ModelPrimitive {
    type NativeType = foxglove::schemas::ModelPrimitive;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let pose = unsafe {
            self.pose
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let scale = unsafe {
            self.scale
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let color = unsafe {
            self.color
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let url = unsafe { string_from_raw(self.url.as_ptr() as *const _, self.url.len(), "url")? };
        let media_type = unsafe {
            string_from_raw(
                self.media_type.as_ptr() as *const _,
                self.media_type.len(),
                "media_type",
            )?
        };

        Ok(ManuallyDrop::new(foxglove::schemas::ModelPrimitive {
            pose: pose.map(ManuallyDrop::into_inner),
            scale: scale.map(ManuallyDrop::into_inner),
            color: color.map(ManuallyDrop::into_inner),
            override_color: self.override_color,
            url: ManuallyDrop::into_inner(url),
            media_type: ManuallyDrop::into_inner(media_type),
            data: ManuallyDrop::into_inner(unsafe { bytes_from_raw(self.data, self.data_len) }),
        }))
    }
}

/// Log a ModelPrimitive message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_model_primitive.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_model_primitive(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&ModelPrimitive>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { ModelPrimitive::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("ModelPrimitive: {}", e);
            e.into()
        }
    }
}

/// Get the ModelPrimitive schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_model_primitive_schema() -> FoxgloveSchema {
    let native =
        foxglove::schemas::ModelPrimitive::get_schema().expect("ModelPrimitive schema is Some");
    let name: &'static str = "foxglove.ModelPrimitive";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("ModelPrimitive schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a ModelPrimitive message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_model_primitive_encode(
    msg: Option<&ModelPrimitive>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { ModelPrimitive::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("ModelPrimitive: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A field present within each element in a byte array of packed elements.
#[repr(C)]
pub struct PackedElementField {
    /// Name of the field
    pub name: FoxgloveString,

    /// Byte offset from start of data buffer
    pub offset: u32,

    /// Type of data in the field. Integers are stored using little-endian byte order.
    pub r#type: FoxgloveNumericType,
}

#[cfg(not(target_family = "wasm"))]
impl PackedElementField {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_packed_element_field(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::PackedElementField>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for PackedElementField {
    type NativeType = foxglove::schemas::PackedElementField;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let name =
            unsafe { string_from_raw(self.name.as_ptr() as *const _, self.name.len(), "name")? };

        Ok(ManuallyDrop::new(foxglove::schemas::PackedElementField {
            name: ManuallyDrop::into_inner(name),
            offset: self.offset,
            r#type: self.r#type as i32,
        }))
    }
}

/// Log a PackedElementField message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_packed_element_field.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_packed_element_field(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&PackedElementField>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { PackedElementField::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("PackedElementField: {}", e);
            e.into()
        }
    }
}

/// Get the PackedElementField schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_packed_element_field_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::PackedElementField::get_schema()
        .expect("PackedElementField schema is Some");
    let name: &'static str = "foxglove.PackedElementField";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("PackedElementField schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a PackedElementField message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_packed_element_field_encode(
    msg: Option<&PackedElementField>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { PackedElementField::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("PackedElementField: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A point representing a position in 2D space
#[repr(C)]
pub struct Point2 {
    /// x coordinate position
    pub x: f64,

    /// y coordinate position
    pub y: f64,
}

#[cfg(not(target_family = "wasm"))]
impl Point2 {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_point2(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result = do_foxglove_channel_create::<foxglove::schemas::Point2>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for Point2 {
    type NativeType = foxglove::schemas::Point2;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        Ok(ManuallyDrop::new(foxglove::schemas::Point2 {
            x: self.x,
            y: self.y,
        }))
    }
}

/// Log a Point2 message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_point2.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_point2(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&Point2>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { Point2::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("Point2: {}", e);
            e.into()
        }
    }
}

/// Get the Point2 schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_point2_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::Point2::get_schema().expect("Point2 schema is Some");
    let name: &'static str = "foxglove.Point2";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("Point2 schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a Point2 message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_point2_encode(
    msg: Option<&Point2>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { Point2::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("Point2: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A point representing a position in 3D space
#[repr(C)]
pub struct Point3 {
    /// x coordinate position
    pub x: f64,

    /// y coordinate position
    pub y: f64,

    /// z coordinate position
    pub z: f64,
}

#[cfg(not(target_family = "wasm"))]
impl Point3 {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_point3(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result = do_foxglove_channel_create::<foxglove::schemas::Point3>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for Point3 {
    type NativeType = foxglove::schemas::Point3;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        Ok(ManuallyDrop::new(foxglove::schemas::Point3 {
            x: self.x,
            y: self.y,
            z: self.z,
        }))
    }
}

/// Log a Point3 message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_point3.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_point3(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&Point3>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { Point3::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("Point3: {}", e);
            e.into()
        }
    }
}

/// Get the Point3 schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_point3_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::Point3::get_schema().expect("Point3 schema is Some");
    let name: &'static str = "foxglove.Point3";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("Point3 schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a Point3 message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_point3_encode(
    msg: Option<&Point3>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { Point3::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("Point3: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A collection of N-dimensional points, which may contain additional fields with information like normals, intensity, etc.
#[repr(C)]
pub struct PointCloud {
    /// Timestamp of point cloud
    pub timestamp: *const FoxgloveTimestamp,

    /// Frame of reference
    pub frame_id: FoxgloveString,

    /// The origin of the point cloud relative to the frame of reference
    pub pose: *const Pose,

    /// Number of bytes between points in the `data`
    pub point_stride: u32,

    /// Fields in `data`. At least 2 coordinate fields from `x`, `y`, and `z` are required for each point's position; `red`, `green`, `blue`, and `alpha` are optional for customizing each point's color.
    pub fields: *const PackedElementField,
    pub fields_count: usize,

    /// Point data, interpreted using `fields`
    pub data: *const c_uchar,
    pub data_len: usize,
}

#[cfg(not(target_family = "wasm"))]
impl PointCloud {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_point_cloud(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::PointCloud>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for PointCloud {
    type NativeType = foxglove::schemas::PointCloud;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let frame_id = unsafe {
            string_from_raw(
                self.frame_id.as_ptr() as *const _,
                self.frame_id.len(),
                "frame_id",
            )?
        };
        let pose = unsafe {
            self.pose
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let fields = unsafe { arena.as_mut().map(self.fields, self.fields_count)? };

        Ok(ManuallyDrop::new(foxglove::schemas::PointCloud {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            frame_id: ManuallyDrop::into_inner(frame_id),
            pose: pose.map(ManuallyDrop::into_inner),
            point_stride: self.point_stride,
            fields: ManuallyDrop::into_inner(fields),
            data: ManuallyDrop::into_inner(unsafe { bytes_from_raw(self.data, self.data_len) }),
        }))
    }
}

/// Log a PointCloud message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_point_cloud.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_point_cloud(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&PointCloud>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { PointCloud::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("PointCloud: {}", e);
            e.into()
        }
    }
}

/// Get the PointCloud schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_point_cloud_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::PointCloud::get_schema().expect("PointCloud schema is Some");
    let name: &'static str = "foxglove.PointCloud";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("PointCloud schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a PointCloud message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_point_cloud_encode(
    msg: Option<&PointCloud>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { PointCloud::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("PointCloud: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// An array of points on a 2D image
#[repr(C)]
pub struct PointsAnnotation {
    /// Timestamp of annotation
    pub timestamp: *const FoxgloveTimestamp,

    /// Type of points annotation to draw
    pub r#type: FoxglovePointsAnnotationType,

    /// Points in 2D image coordinates (pixels).
    /// These coordinates use the top-left corner of the top-left pixel of the image as the origin.
    pub points: *const Point2,
    pub points_count: usize,

    /// Outline color
    pub outline_color: *const Color,

    /// Per-point colors, if `type` is `POINTS`, or per-segment stroke colors, if `type` is `LINE_LIST`, `LINE_STRIP` or `LINE_LOOP`.
    pub outline_colors: *const Color,
    pub outline_colors_count: usize,

    /// Fill color
    pub fill_color: *const Color,

    /// Stroke thickness in pixels
    pub thickness: f64,
}

#[cfg(not(target_family = "wasm"))]
impl PointsAnnotation {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_points_annotation(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::PointsAnnotation>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for PointsAnnotation {
    type NativeType = foxglove::schemas::PointsAnnotation;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let points = unsafe { arena.as_mut().map(self.points, self.points_count)? };
        let outline_color = unsafe {
            self.outline_color
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let outline_colors = unsafe {
            arena
                .as_mut()
                .map(self.outline_colors, self.outline_colors_count)?
        };
        let fill_color = unsafe {
            self.fill_color
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;

        Ok(ManuallyDrop::new(foxglove::schemas::PointsAnnotation {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            r#type: self.r#type as i32,
            points: ManuallyDrop::into_inner(points),
            outline_color: outline_color.map(ManuallyDrop::into_inner),
            outline_colors: ManuallyDrop::into_inner(outline_colors),
            fill_color: fill_color.map(ManuallyDrop::into_inner),
            thickness: self.thickness,
        }))
    }
}

/// Log a PointsAnnotation message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_points_annotation.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_points_annotation(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&PointsAnnotation>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { PointsAnnotation::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("PointsAnnotation: {}", e);
            e.into()
        }
    }
}

/// Get the PointsAnnotation schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_points_annotation_schema() -> FoxgloveSchema {
    let native =
        foxglove::schemas::PointsAnnotation::get_schema().expect("PointsAnnotation schema is Some");
    let name: &'static str = "foxglove.PointsAnnotation";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("PointsAnnotation schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a PointsAnnotation message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_points_annotation_encode(
    msg: Option<&PointsAnnotation>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { PointsAnnotation::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("PointsAnnotation: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A position and orientation for an object or reference frame in 3D space
#[repr(C)]
pub struct Pose {
    /// Point denoting position in 3D space
    pub position: *const Vector3,

    /// Quaternion denoting orientation in 3D space
    pub orientation: *const Quaternion,
}

#[cfg(not(target_family = "wasm"))]
impl Pose {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_pose(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result = do_foxglove_channel_create::<foxglove::schemas::Pose>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for Pose {
    type NativeType = foxglove::schemas::Pose;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let position = unsafe {
            self.position
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let orientation = unsafe {
            self.orientation
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;

        Ok(ManuallyDrop::new(foxglove::schemas::Pose {
            position: position.map(ManuallyDrop::into_inner),
            orientation: orientation.map(ManuallyDrop::into_inner),
        }))
    }
}

/// Log a Pose message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_pose.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_pose(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&Pose>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { Pose::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("Pose: {}", e);
            e.into()
        }
    }
}

/// Get the Pose schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_pose_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::Pose::get_schema().expect("Pose schema is Some");
    let name: &'static str = "foxglove.Pose";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("Pose schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a Pose message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_pose_encode(
    msg: Option<&Pose>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { Pose::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("Pose: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A timestamped pose for an object or reference frame in 3D space
#[repr(C)]
pub struct PoseInFrame {
    /// Timestamp of pose
    pub timestamp: *const FoxgloveTimestamp,

    /// Frame of reference for pose position and orientation
    pub frame_id: FoxgloveString,

    /// Pose in 3D space
    pub pose: *const Pose,
}

#[cfg(not(target_family = "wasm"))]
impl PoseInFrame {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_pose_in_frame(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::PoseInFrame>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for PoseInFrame {
    type NativeType = foxglove::schemas::PoseInFrame;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let frame_id = unsafe {
            string_from_raw(
                self.frame_id.as_ptr() as *const _,
                self.frame_id.len(),
                "frame_id",
            )?
        };
        let pose = unsafe {
            self.pose
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;

        Ok(ManuallyDrop::new(foxglove::schemas::PoseInFrame {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            frame_id: ManuallyDrop::into_inner(frame_id),
            pose: pose.map(ManuallyDrop::into_inner),
        }))
    }
}

/// Log a PoseInFrame message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_pose_in_frame.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_pose_in_frame(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&PoseInFrame>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { PoseInFrame::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("PoseInFrame: {}", e);
            e.into()
        }
    }
}

/// Get the PoseInFrame schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_pose_in_frame_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::PoseInFrame::get_schema().expect("PoseInFrame schema is Some");
    let name: &'static str = "foxglove.PoseInFrame";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("PoseInFrame schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a PoseInFrame message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_pose_in_frame_encode(
    msg: Option<&PoseInFrame>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { PoseInFrame::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("PoseInFrame: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// An array of timestamped poses for an object or reference frame in 3D space
#[repr(C)]
pub struct PosesInFrame {
    /// Timestamp of pose
    pub timestamp: *const FoxgloveTimestamp,

    /// Frame of reference for pose position and orientation
    pub frame_id: FoxgloveString,

    /// Poses in 3D space
    pub poses: *const Pose,
    pub poses_count: usize,
}

#[cfg(not(target_family = "wasm"))]
impl PosesInFrame {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_poses_in_frame(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::PosesInFrame>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for PosesInFrame {
    type NativeType = foxglove::schemas::PosesInFrame;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let frame_id = unsafe {
            string_from_raw(
                self.frame_id.as_ptr() as *const _,
                self.frame_id.len(),
                "frame_id",
            )?
        };
        let poses = unsafe { arena.as_mut().map(self.poses, self.poses_count)? };

        Ok(ManuallyDrop::new(foxglove::schemas::PosesInFrame {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            frame_id: ManuallyDrop::into_inner(frame_id),
            poses: ManuallyDrop::into_inner(poses),
        }))
    }
}

/// Log a PosesInFrame message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_poses_in_frame.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_poses_in_frame(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&PosesInFrame>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { PosesInFrame::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("PosesInFrame: {}", e);
            e.into()
        }
    }
}

/// Get the PosesInFrame schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_poses_in_frame_schema() -> FoxgloveSchema {
    let native =
        foxglove::schemas::PosesInFrame::get_schema().expect("PosesInFrame schema is Some");
    let name: &'static str = "foxglove.PosesInFrame";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("PosesInFrame schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a PosesInFrame message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_poses_in_frame_encode(
    msg: Option<&PosesInFrame>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { PosesInFrame::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("PosesInFrame: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A [quaternion](https://eater.net/quaternions) representing a rotation in 3D space
#[repr(C)]
pub struct Quaternion {
    /// x value
    pub x: f64,

    /// y value
    pub y: f64,

    /// z value
    pub z: f64,

    /// w value
    pub w: f64,
}

#[cfg(not(target_family = "wasm"))]
impl Quaternion {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_quaternion(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::Quaternion>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for Quaternion {
    type NativeType = foxglove::schemas::Quaternion;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        Ok(ManuallyDrop::new(foxglove::schemas::Quaternion {
            x: self.x,
            y: self.y,
            z: self.z,
            w: self.w,
        }))
    }
}

/// Log a Quaternion message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_quaternion.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_quaternion(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&Quaternion>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { Quaternion::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("Quaternion: {}", e);
            e.into()
        }
    }
}

/// Get the Quaternion schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_quaternion_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::Quaternion::get_schema().expect("Quaternion schema is Some");
    let name: &'static str = "foxglove.Quaternion";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("Quaternion schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a Quaternion message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_quaternion_encode(
    msg: Option<&Quaternion>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { Quaternion::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("Quaternion: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A single block of an audio bitstream
#[repr(C)]
pub struct RawAudio {
    /// Timestamp of the start of the audio block
    pub timestamp: *const FoxgloveTimestamp,

    /// Audio data. The samples in the data must be interleaved and little-endian
    pub data: *const c_uchar,
    pub data_len: usize,

    /// Audio format. Only 'pcm-s16' is currently supported
    pub format: FoxgloveString,

    /// Sample rate in Hz
    pub sample_rate: u32,

    /// Number of channels in the audio block
    pub number_of_channels: u32,
}

#[cfg(not(target_family = "wasm"))]
impl RawAudio {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_raw_audio(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result = do_foxglove_channel_create::<foxglove::schemas::RawAudio>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for RawAudio {
    type NativeType = foxglove::schemas::RawAudio;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let format = unsafe {
            string_from_raw(
                self.format.as_ptr() as *const _,
                self.format.len(),
                "format",
            )?
        };

        Ok(ManuallyDrop::new(foxglove::schemas::RawAudio {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            data: ManuallyDrop::into_inner(unsafe { bytes_from_raw(self.data, self.data_len) }),
            format: ManuallyDrop::into_inner(format),
            sample_rate: self.sample_rate,
            number_of_channels: self.number_of_channels,
        }))
    }
}

/// Log a RawAudio message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_raw_audio.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_raw_audio(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&RawAudio>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { RawAudio::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("RawAudio: {}", e);
            e.into()
        }
    }
}

/// Get the RawAudio schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_raw_audio_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::RawAudio::get_schema().expect("RawAudio schema is Some");
    let name: &'static str = "foxglove.RawAudio";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("RawAudio schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a RawAudio message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_raw_audio_encode(
    msg: Option<&RawAudio>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { RawAudio::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("RawAudio: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A raw image
#[repr(C)]
pub struct RawImage {
    /// Timestamp of image
    pub timestamp: *const FoxgloveTimestamp,

    /// Frame of reference for the image. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
    pub frame_id: FoxgloveString,

    /// Image width in pixels
    pub width: u32,

    /// Image height in pixels
    pub height: u32,

    /// Encoding of the raw image data. See the `data` field description for supported values.
    pub encoding: FoxgloveString,

    /// Byte length of a single row. This is usually some multiple of `width` depending on the encoding, but can be greater to incorporate padding.
    pub step: u32,

    /// Raw image data.
    ///
    /// For each `encoding` value, the `data` field contains image pixel data serialized as follows:
    ///
    /// - `yuv422` or `uyvy`:
    ///   - Pixel colors are decomposed into [Y'UV](https://en.wikipedia.org/wiki/Y%E2%80%B2UV) channels.
    ///   - Pixel channel values are represented as unsigned 8-bit integers.
    ///   - U and V values are shared between horizontal pairs of pixels. Each pair of output pixels is serialized as [U, Y1, V, Y2].
    ///   - `step` must be greater than or equal to `width` * 2.
    /// - `yuv422_yuy2` or  `yuyv`:
    ///   - Pixel colors are decomposed into [Y'UV](https://en.wikipedia.org/wiki/Y%E2%80%B2UV) channels.
    ///   - Pixel channel values are represented as unsigned 8-bit integers.
    ///   - U and V values are shared between horizontal pairs of pixels. Each pair of output pixels is encoded as [Y1, U, Y2, V].
    ///   - `step` must be greater than or equal to `width` * 2.
    /// - `rgb8`:
    ///   - Pixel colors are decomposed into Red, Green, and Blue channels.
    ///   - Pixel channel values are represented as unsigned 8-bit integers.
    ///   - Each output pixel is serialized as [R, G, B].
    ///   - `step` must be greater than or equal to `width` * 3.
    /// - `rgba8`:
    ///   - Pixel colors are decomposed into Red, Green, Blue, and Alpha channels.
    ///   - Pixel channel values are represented as unsigned 8-bit integers.
    ///   - Each output pixel is serialized as [R, G, B, Alpha].
    ///   - `step` must be greater than or equal to `width` * 4.
    /// - `bgr8` or `8UC3`:
    ///   - Pixel colors are decomposed into Blue, Green, and Red channels.
    ///   - Pixel channel values are represented as unsigned 8-bit integers.
    ///   - Each output pixel is serialized as [B, G, R].
    ///   - `step` must be greater than or equal to `width` * 3.
    /// - `bgra8`:
    ///   - Pixel colors are decomposed into Blue, Green, Red, and Alpha channels.
    ///   - Pixel channel values are represented as unsigned 8-bit integers.
    ///   - Each output pixel is encoded as [B, G, R, Alpha].
    ///   - `step` must be greater than or equal to `width` * 4.
    /// - `32FC1`:
    ///   - Pixel brightness is represented as a single-channel, 32-bit little-endian IEEE 754 floating-point value, ranging from 0.0 (black) to 1.0 (white).
    ///   - `step` must be greater than or equal to `width` * 4.
    /// - `bayer_rggb8`, `bayer_bggr8`, `bayer_rggb8`, `bayer_gbrg8`, or `bayer_grgb8`:
    ///   - Pixel colors are decomposed into Red, Blue and Green channels.
    ///   - Pixel channel values are represented as unsigned 8-bit integers, and serialized in a 2x2 bayer filter pattern.
    ///   - The order of the four letters after `bayer_` determine the layout, so for `bayer_wxyz8` the pattern is:
    ///   ```plaintext
    ///   w | x
    ///   - + -
    ///   y | z
    ///   ```
    ///   - `step` must be greater than or equal to `width`.
    /// - `mono8` or `8UC1`:
    ///   - Pixel brightness is represented as unsigned 8-bit integers.
    ///   - `step` must be greater than or equal to `width`.
    /// - `mono16` or `16UC1`:
    ///   - Pixel brightness is represented as 16-bit unsigned little-endian integers. Rendering of these values is controlled in [Image panel color mode settings](https://docs.foxglove.dev/docs/visualization/panels/image#general).
    ///   - `step` must be greater than or equal to `width` * 2.
    ///
    pub data: *const c_uchar,
    pub data_len: usize,
}

#[cfg(not(target_family = "wasm"))]
impl RawImage {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_raw_image(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result = do_foxglove_channel_create::<foxglove::schemas::RawImage>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for RawImage {
    type NativeType = foxglove::schemas::RawImage;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let frame_id = unsafe {
            string_from_raw(
                self.frame_id.as_ptr() as *const _,
                self.frame_id.len(),
                "frame_id",
            )?
        };
        let encoding = unsafe {
            string_from_raw(
                self.encoding.as_ptr() as *const _,
                self.encoding.len(),
                "encoding",
            )?
        };

        Ok(ManuallyDrop::new(foxglove::schemas::RawImage {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            frame_id: ManuallyDrop::into_inner(frame_id),
            width: self.width,
            height: self.height,
            encoding: ManuallyDrop::into_inner(encoding),
            step: self.step,
            data: ManuallyDrop::into_inner(unsafe { bytes_from_raw(self.data, self.data_len) }),
        }))
    }
}

/// Log a RawImage message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_raw_image.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_raw_image(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&RawImage>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { RawImage::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("RawImage: {}", e);
            e.into()
        }
    }
}

/// Get the RawImage schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_raw_image_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::RawImage::get_schema().expect("RawImage schema is Some");
    let name: &'static str = "foxglove.RawImage";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("RawImage schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a RawImage message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_raw_image_encode(
    msg: Option<&RawImage>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { RawImage::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("RawImage: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A primitive representing a sphere or ellipsoid
#[repr(C)]
pub struct SpherePrimitive {
    /// Position of the center of the sphere and orientation of the sphere
    pub pose: *const Pose,

    /// Size (diameter) of the sphere along each axis
    pub size: *const Vector3,

    /// Color of the sphere
    pub color: *const Color,
}

#[cfg(not(target_family = "wasm"))]
impl SpherePrimitive {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_sphere_primitive(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::SpherePrimitive>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for SpherePrimitive {
    type NativeType = foxglove::schemas::SpherePrimitive;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let pose = unsafe {
            self.pose
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let size = unsafe {
            self.size
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let color = unsafe {
            self.color
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;

        Ok(ManuallyDrop::new(foxglove::schemas::SpherePrimitive {
            pose: pose.map(ManuallyDrop::into_inner),
            size: size.map(ManuallyDrop::into_inner),
            color: color.map(ManuallyDrop::into_inner),
        }))
    }
}

/// Log a SpherePrimitive message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_sphere_primitive.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_sphere_primitive(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&SpherePrimitive>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { SpherePrimitive::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("SpherePrimitive: {}", e);
            e.into()
        }
    }
}

/// Get the SpherePrimitive schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_sphere_primitive_schema() -> FoxgloveSchema {
    let native =
        foxglove::schemas::SpherePrimitive::get_schema().expect("SpherePrimitive schema is Some");
    let name: &'static str = "foxglove.SpherePrimitive";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("SpherePrimitive schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a SpherePrimitive message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_sphere_primitive_encode(
    msg: Option<&SpherePrimitive>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { SpherePrimitive::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("SpherePrimitive: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A text label on a 2D image
#[repr(C)]
pub struct TextAnnotation {
    /// Timestamp of annotation
    pub timestamp: *const FoxgloveTimestamp,

    /// Bottom-left origin of the text label in 2D image coordinates (pixels).
    /// The coordinate uses the top-left corner of the top-left pixel of the image as the origin.
    pub position: *const Point2,

    /// Text to display
    pub text: FoxgloveString,

    /// Font size in pixels
    pub font_size: f64,

    /// Text color
    pub text_color: *const Color,

    /// Background fill color
    pub background_color: *const Color,
}

#[cfg(not(target_family = "wasm"))]
impl TextAnnotation {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_text_annotation(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::TextAnnotation>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for TextAnnotation {
    type NativeType = foxglove::schemas::TextAnnotation;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let position = unsafe {
            self.position
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let text =
            unsafe { string_from_raw(self.text.as_ptr() as *const _, self.text.len(), "text")? };
        let text_color = unsafe {
            self.text_color
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let background_color = unsafe {
            self.background_color
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;

        Ok(ManuallyDrop::new(foxglove::schemas::TextAnnotation {
            timestamp: unsafe { self.timestamp.as_ref() }.map(|&m| m.into()),
            position: position.map(ManuallyDrop::into_inner),
            text: ManuallyDrop::into_inner(text),
            font_size: self.font_size,
            text_color: text_color.map(ManuallyDrop::into_inner),
            background_color: background_color.map(ManuallyDrop::into_inner),
        }))
    }
}

/// Log a TextAnnotation message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_text_annotation.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_text_annotation(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&TextAnnotation>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { TextAnnotation::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("TextAnnotation: {}", e);
            e.into()
        }
    }
}

/// Get the TextAnnotation schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_text_annotation_schema() -> FoxgloveSchema {
    let native =
        foxglove::schemas::TextAnnotation::get_schema().expect("TextAnnotation schema is Some");
    let name: &'static str = "foxglove.TextAnnotation";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("TextAnnotation schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a TextAnnotation message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_text_annotation_encode(
    msg: Option<&TextAnnotation>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { TextAnnotation::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("TextAnnotation: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A primitive representing a text label
#[repr(C)]
pub struct TextPrimitive {
    /// Position of the center of the text box and orientation of the text. Identity orientation means the text is oriented in the xy-plane and flows from -x to +x.
    pub pose: *const Pose,

    /// Whether the text should respect `pose.orientation` (false) or always face the camera (true)
    pub billboard: bool,

    /// Font size (height of one line of text)
    pub font_size: f64,

    /// Indicates whether `font_size` is a fixed size in screen pixels (true), or specified in world coordinates and scales with distance from the camera (false)
    pub scale_invariant: bool,

    /// Color of the text
    pub color: *const Color,

    /// Text
    pub text: FoxgloveString,
}

#[cfg(not(target_family = "wasm"))]
impl TextPrimitive {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_text_primitive(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result =
                do_foxglove_channel_create::<foxglove::schemas::TextPrimitive>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for TextPrimitive {
    type NativeType = foxglove::schemas::TextPrimitive;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let pose = unsafe {
            self.pose
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let color = unsafe {
            self.color
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let text =
            unsafe { string_from_raw(self.text.as_ptr() as *const _, self.text.len(), "text")? };

        Ok(ManuallyDrop::new(foxglove::schemas::TextPrimitive {
            pose: pose.map(ManuallyDrop::into_inner),
            billboard: self.billboard,
            font_size: self.font_size,
            scale_invariant: self.scale_invariant,
            color: color.map(ManuallyDrop::into_inner),
            text: ManuallyDrop::into_inner(text),
        }))
    }
}

/// Log a TextPrimitive message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_text_primitive.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_text_primitive(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&TextPrimitive>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { TextPrimitive::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("TextPrimitive: {}", e);
            e.into()
        }
    }
}

/// Get the TextPrimitive schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_text_primitive_schema() -> FoxgloveSchema {
    let native =
        foxglove::schemas::TextPrimitive::get_schema().expect("TextPrimitive schema is Some");
    let name: &'static str = "foxglove.TextPrimitive";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("TextPrimitive schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a TextPrimitive message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_text_primitive_encode(
    msg: Option<&TextPrimitive>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { TextPrimitive::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("TextPrimitive: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A primitive representing a set of triangles or a surface tiled by triangles
#[repr(C)]
pub struct TriangleListPrimitive {
    /// Origin of triangles relative to reference frame
    pub pose: *const Pose,

    /// Vertices to use for triangles, interpreted as a list of triples (0-1-2, 3-4-5, ...)
    pub points: *const Point3,
    pub points_count: usize,

    /// Solid color to use for the whole shape. One of `color` or `colors` must be provided.
    pub color: *const Color,

    /// Per-vertex colors (if specified, must have the same length as `points`). One of `color` or `colors` must be provided.
    pub colors: *const Color,
    pub colors_count: usize,

    /// Indices into the `points` and `colors` attribute arrays, which can be used to avoid duplicating attribute data.
    ///
    /// If omitted or empty, indexing will not be used. This default behavior is equivalent to specifying [0, 1, ..., N-1] for the indices (where N is the number of `points` provided).
    pub indices: *const u32,
    pub indices_count: usize,
}

#[cfg(not(target_family = "wasm"))]
impl TriangleListPrimitive {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_triangle_list_primitive(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result = do_foxglove_channel_create::<foxglove::schemas::TriangleListPrimitive>(
                topic, context,
            );
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for TriangleListPrimitive {
    type NativeType = foxglove::schemas::TriangleListPrimitive;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        let pose = unsafe {
            self.pose
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let points = unsafe { arena.as_mut().map(self.points, self.points_count)? };
        let color = unsafe {
            self.color
                .as_ref()
                .map(|m| m.borrow_to_native(arena.as_mut()))
        }
        .transpose()?;
        let colors = unsafe { arena.as_mut().map(self.colors, self.colors_count)? };

        Ok(ManuallyDrop::new(
            foxglove::schemas::TriangleListPrimitive {
                pose: pose.map(ManuallyDrop::into_inner),
                points: ManuallyDrop::into_inner(points),
                color: color.map(ManuallyDrop::into_inner),
                colors: ManuallyDrop::into_inner(colors),
                indices: ManuallyDrop::into_inner(unsafe {
                    vec_from_raw(self.indices as *mut u32, self.indices_count)
                }),
            },
        ))
    }
}

/// Log a TriangleListPrimitive message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_triangle_list_primitive.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_triangle_list_primitive(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&TriangleListPrimitive>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { TriangleListPrimitive::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("TriangleListPrimitive: {}", e);
            e.into()
        }
    }
}

/// Get the TriangleListPrimitive schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_triangle_list_primitive_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::TriangleListPrimitive::get_schema()
        .expect("TriangleListPrimitive schema is Some");
    let name: &'static str = "foxglove.TriangleListPrimitive";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("TriangleListPrimitive schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a TriangleListPrimitive message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_triangle_list_primitive_encode(
    msg: Option<&TriangleListPrimitive>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { TriangleListPrimitive::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("TriangleListPrimitive: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A vector in 2D space that represents a direction only
#[repr(C)]
pub struct Vector2 {
    /// x coordinate length
    pub x: f64,

    /// y coordinate length
    pub y: f64,
}

#[cfg(not(target_family = "wasm"))]
impl Vector2 {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_vector2(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result = do_foxglove_channel_create::<foxglove::schemas::Vector2>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for Vector2 {
    type NativeType = foxglove::schemas::Vector2;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        Ok(ManuallyDrop::new(foxglove::schemas::Vector2 {
            x: self.x,
            y: self.y,
        }))
    }
}

/// Log a Vector2 message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_vector2.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_vector2(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&Vector2>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { Vector2::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("Vector2: {}", e);
            e.into()
        }
    }
}

/// Get the Vector2 schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_vector2_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::Vector2::get_schema().expect("Vector2 schema is Some");
    let name: &'static str = "foxglove.Vector2";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("Vector2 schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a Vector2 message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_vector2_encode(
    msg: Option<&Vector2>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { Vector2::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("Vector2: {}", e);
            FoxgloveError::EncodeError
        }
    }
}

/// A vector in 3D space that represents a direction only
#[repr(C)]
pub struct Vector3 {
    /// x coordinate length
    pub x: f64,

    /// y coordinate length
    pub y: f64,

    /// z coordinate length
    pub z: f64,
}

#[cfg(not(target_family = "wasm"))]
impl Vector3 {
    /// Create a new typed channel, and return an owned raw channel pointer to it.
    ///
    /// # Safety
    /// We're trusting the caller that the channel will only be used with this type T.
    #[unsafe(no_mangle)]
    pub unsafe extern "C" fn foxglove_channel_create_vector3(
        topic: FoxgloveString,
        context: *const FoxgloveContext,
        channel: *mut *const FoxgloveChannel,
    ) -> FoxgloveError {
        if channel.is_null() {
            tracing::error!("channel cannot be null");
            return FoxgloveError::ValueError;
        }
        unsafe {
            let result = do_foxglove_channel_create::<foxglove::schemas::Vector3>(topic, context);
            result_to_c(result, channel)
        }
    }
}

impl BorrowToNative for Vector3 {
    type NativeType = foxglove::schemas::Vector3;

    unsafe fn borrow_to_native(
        &self,
        #[allow(unused_mut, unused_variables)] mut arena: Pin<&mut Arena>,
    ) -> Result<ManuallyDrop<Self::NativeType>, foxglove::FoxgloveError> {
        Ok(ManuallyDrop::new(foxglove::schemas::Vector3 {
            x: self.x,
            y: self.y,
            z: self.z,
        }))
    }
}

/// Log a Vector3 message to a channel.
///
/// # Safety
/// The channel must have been created for this type with foxglove_channel_create_vector3.
#[cfg(not(target_family = "wasm"))]
#[unsafe(no_mangle)]
pub extern "C" fn foxglove_channel_log_vector3(
    channel: Option<&FoxgloveChannel>,
    msg: Option<&Vector3>,
    log_time: Option<&u64>,
    sink_id: FoxgloveSinkId,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { Vector3::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            // Safety: this casts channel back to a typed channel for type of msg, it must have been created for this type.
            log_msg_to_channel(channel, &*msg, log_time, sink_id)
        }
        Err(e) => {
            tracing::error!("Vector3: {}", e);
            e.into()
        }
    }
}

/// Get the Vector3 schema.
///
/// All buffers in the returned schema are statically allocated.
#[allow(
    clippy::missing_safety_doc,
    reason = "no preconditions and returned lifetime is static"
)]
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_vector3_schema() -> FoxgloveSchema {
    let native = foxglove::schemas::Vector3::get_schema().expect("Vector3 schema is Some");
    let name: &'static str = "foxglove.Vector3";
    let encoding: &'static str = "protobuf";
    assert_eq!(name, &native.name);
    assert_eq!(encoding, &native.encoding);
    let std::borrow::Cow::Borrowed(data) = native.data else {
        unreachable!("Vector3 schema data is static");
    };
    FoxgloveSchema {
        name: name.into(),
        encoding: encoding.into(),
        data: data.as_ptr(),
        data_len: data.len(),
    }
}

/// Encode a Vector3 message as protobuf to the buffer provided.
///
/// On success, writes the encoded length to *encoded_len.
/// If the provided buffer has insufficient capacity, writes the required capacity to *encoded_len and
/// returns FOXGLOVE_ERROR_BUFFER_TOO_SHORT.
/// If the message cannot be encoded, logs the reason to stderr and returns FOXGLOVE_ERROR_ENCODE.
///
/// # Safety
/// ptr must be a valid pointer to a memory region at least len bytes long.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn foxglove_vector3_encode(
    msg: Option<&Vector3>,
    ptr: *mut u8,
    len: usize,
    encoded_len: Option<&mut usize>,
) -> FoxgloveError {
    let mut arena = pin!(Arena::new());
    let arena_pin = arena.as_mut();
    // Safety: we're borrowing from the msg, but discard the borrowed message before returning
    match unsafe { Vector3::borrow_option_to_native(msg, arena_pin) } {
        Ok(msg) => {
            if len == 0 || ptr.is_null() {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = msg
                        .encoded_len()
                        .expect("foxglove schemas return Some(len)");
                }
                return FoxgloveError::BufferTooShort;
            }
            let mut buf = unsafe { core::slice::from_raw_parts_mut(ptr, len) };
            if let Err(encode_error) = msg.encode(&mut buf) {
                if let Some(encoded_len) = encoded_len {
                    *encoded_len = encode_error.required_capacity();
                }
                return FoxgloveError::BufferTooShort;
            }
            if let Some(encoded_len) = encoded_len {
                *encoded_len = len - buf.len();
            }
            FoxgloveError::Ok
        }
        Err(e) => {
            tracing::error!("Vector3: {}", e);
            FoxgloveError::EncodeError
        }
    }
}
