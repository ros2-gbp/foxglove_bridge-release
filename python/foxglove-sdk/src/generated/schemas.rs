//! Definitions for well-known Foxglove schemas
//! Generated by https://github.com/foxglove/foxglove-sdk
#![allow(clippy::too_many_arguments)]
#![allow(clippy::enum_variant_names)]
#![allow(non_snake_case)]
use crate::schemas_wkt::{Duration, Timestamp};
use crate::PySchema;
use bytes::Bytes;
use foxglove::Encode;
use pyo3::prelude::*;
use pyo3::types::PyBytes;

/// An enumeration indicating how input points should be interpreted to create lines
#[pyclass(eq, eq_int, module = "foxglove.schemas")]
#[derive(PartialEq, Clone)]
pub(crate) enum LinePrimitiveLineType {
    LineStrip = 0,
    LineLoop = 1,
    LineList = 2,
}

/// Log level
#[pyclass(eq, eq_int, module = "foxglove.schemas")]
#[derive(PartialEq, Clone)]
pub(crate) enum LogLevel {
    Unknown = 0,
    Debug = 1,
    Info = 2,
    Warning = 3,
    Error = 4,
    Fatal = 5,
}

/// An enumeration indicating which entities should match a SceneEntityDeletion command
#[pyclass(eq, eq_int, module = "foxglove.schemas")]
#[derive(PartialEq, Clone)]
pub(crate) enum SceneEntityDeletionType {
    MatchingId = 0,
    All = 1,
}

/// Numeric type
#[pyclass(eq, eq_int, module = "foxglove.schemas")]
#[derive(PartialEq, Clone)]
pub(crate) enum PackedElementFieldNumericType {
    Unknown = 0,
    Uint8 = 1,
    Int8 = 2,
    Uint16 = 3,
    Int16 = 4,
    Uint32 = 5,
    Int32 = 6,
    Float32 = 7,
    Float64 = 8,
}

/// Type of points annotation
#[pyclass(eq, eq_int, module = "foxglove.schemas")]
#[derive(PartialEq, Clone)]
pub(crate) enum PointsAnnotationType {
    Unknown = 0,
    Points = 1,
    LineLoop = 2,
    LineStrip = 3,
    LineList = 4,
}

/// Type of position covariance
#[pyclass(eq, eq_int, module = "foxglove.schemas")]
#[derive(PartialEq, Clone)]
pub(crate) enum LocationFixPositionCovarianceType {
    Unknown = 0,
    Approximated = 1,
    DiagonalKnown = 2,
    Known = 3,
}

/// A primitive representing an arrow
///
/// :param pose: Position of the arrow's tail and orientation of the arrow. Identity orientation means the arrow points in the +x direction.
/// :param shaft_length: Length of the arrow shaft
/// :param shaft_diameter: Diameter of the arrow shaft
/// :param head_length: Length of the arrow head
/// :param head_diameter: Diameter of the arrow head
/// :param color: Color of the arrow
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/arrow-primitive
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct ArrowPrimitive(pub(crate) foxglove::schemas::ArrowPrimitive);
#[pymethods]
impl ArrowPrimitive {
    #[new]
    #[pyo3(signature = (*, pose=None, shaft_length=0.0, shaft_diameter=0.0, head_length=0.0, head_diameter=0.0, color=None) )]
    fn new(
        pose: Option<Pose>,
        shaft_length: f64,
        shaft_diameter: f64,
        head_length: f64,
        head_diameter: f64,
        color: Option<Color>,
    ) -> Self {
        Self(foxglove::schemas::ArrowPrimitive {
            pose: pose.map(Into::into),
            shaft_length,
            shaft_diameter,
            head_length,
            head_diameter,
            color: color.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "ArrowPrimitive(pose={:?}, shaft_length={:?}, shaft_diameter={:?}, head_length={:?}, head_diameter={:?}, color={:?})",
            self.0.pose,
            self.0.shaft_length,
            self.0.shaft_diameter,
            self.0.head_length,
            self.0.head_diameter,
            self.0.color,
        )
    }
    /// Returns the ArrowPrimitive schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::ArrowPrimitive::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the ArrowPrimitive as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<ArrowPrimitive> for foxglove::schemas::ArrowPrimitive {
    fn from(value: ArrowPrimitive) -> Self {
        value.0
    }
}

/// Camera calibration parameters
///
/// :param timestamp: Timestamp of calibration data
/// :param frame_id: Frame of reference for the camera. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
/// :param width: Image width
/// :param height: Image height
/// :param distortion_model: Name of distortion model
///     
///     Supported parameters: `plumb_bob` (k1, k2, p1, p2, k3), `rational_polynomial` (k1, k2, p1, p2, k3, k4, k5, k6), and `kannala_brandt` (k1, k2, k3, k4), and `fisheye62` (k0, k1, k2, k3, p0, p1, crit_theta [optional]). `plumb_bob` and `rational_polynomial` models are based on the pinhole model `OpenCV's <https://docs.opencv.org/4.11.0/d9/d0c/group__calib3d.html>`__ `pinhole camera model <https://en.wikipedia.org/wiki/Distortion_%28optics%29#Software_correction>`__. The `kannala_brandt` model matches the `OpenvCV fisheye <https://docs.opencv.org/4.11.0/db/d58/group__calib3d__fisheye.html>`__ model. The `fisheye62` model matches the `Project Aria's Fisheye62 Model <https://facebookresearch.github.io/projectaria_tools/docs/tech_insights/camera_intrinsic_models>`__.
/// :param D: Distortion parameters
/// :param K: Intrinsic camera matrix (3x3 row-major matrix)
///     
///     A 3x3 row-major matrix for the raw (distorted) image.
///     
///     Projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal lengths (fx, fy) and principal point (cx, cy).
///     
///     ::
///
///             [fx  0 cx]
///         K = [ 0 fy cy]
///             [ 0  0  1]
///     
/// :param R: Rectification matrix (stereo cameras only, 3x3 row-major matrix)
///     
///     A rotation matrix aligning the camera coordinate system to the ideal stereo image plane so that epipolar lines in both stereo images are parallel.
/// :param P: Projection/camera matrix (3x4 row-major matrix)
///     
///     ::
///
///             [fx'  0  cx' Tx]
///         P = [ 0  fy' cy' Ty]
///             [ 0   0   1   0]
///     
///     By convention, this matrix specifies the intrinsic (camera) matrix of the processed (rectified) image. That is, the left 3x3 portion is the normal camera intrinsic matrix for the rectified image.
///     
///     It projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal lengths (fx', fy') and principal point (cx', cy') - these may differ from the values in K.
///     
///     For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will also have R = the identity and P[1:3,1:3] = K.
///     
///     Foxglove currently does not support displaying stereo images, so Tx and Ty are ignored.
///     
///     Given a 3D point [X Y Z]', the projection (x, y) of the point onto the rectified image is given by:
///     
///     ::
///
///         [u v w]' = P * [X Y Z 1]'
///                x = u / w
///                y = v / w
///     
///     This holds for both images of a stereo pair.
///     
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/camera-calibration
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct CameraCalibration(pub(crate) foxglove::schemas::CameraCalibration);
#[pymethods]
impl CameraCalibration {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", width=0, height=0, distortion_model="", D=None, K=None, R=None, P=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        width: u32,
        height: u32,
        distortion_model: &str,
        D: Option<Vec<f64>>,
        K: Option<Vec<f64>>,
        R: Option<Vec<f64>>,
        P: Option<Vec<f64>>,
    ) -> Self {
        Self(foxglove::schemas::CameraCalibration {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            width,
            height,
            distortion_model: distortion_model.to_string(),
            d: D.unwrap_or_default(),
            k: K.unwrap_or_default(),
            r: R.unwrap_or_default(),
            p: P.unwrap_or_default(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "CameraCalibration(timestamp={:?}, frame_id={:?}, width={:?}, height={:?}, distortion_model={:?}, D={:?}, K={:?}, R={:?}, P={:?})",
            self.0.timestamp,
            self.0.frame_id,
            self.0.width,
            self.0.height,
            self.0.distortion_model,
            self.0.d,
            self.0.k,
            self.0.r,
            self.0.p,
        )
    }
    /// Returns the CameraCalibration schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::CameraCalibration::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the CameraCalibration as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<CameraCalibration> for foxglove::schemas::CameraCalibration {
    fn from(value: CameraCalibration) -> Self {
        value.0
    }
}

/// A circle annotation on a 2D image
///
/// :param timestamp: Timestamp of circle
/// :param position: Center of the circle in 2D image coordinates (pixels).
///     The coordinate uses the top-left corner of the top-left pixel of the image as the origin.
/// :param diameter: Circle diameter in pixels
/// :param thickness: Line thickness in pixels
/// :param fill_color: Fill color
/// :param outline_color: Outline color
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/circle-annotation
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct CircleAnnotation(pub(crate) foxglove::schemas::CircleAnnotation);
#[pymethods]
impl CircleAnnotation {
    #[new]
    #[pyo3(signature = (*, timestamp=None, position=None, diameter=0.0, thickness=0.0, fill_color=None, outline_color=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        position: Option<Point2>,
        diameter: f64,
        thickness: f64,
        fill_color: Option<Color>,
        outline_color: Option<Color>,
    ) -> Self {
        Self(foxglove::schemas::CircleAnnotation {
            timestamp: timestamp.map(Into::into),
            position: position.map(Into::into),
            diameter,
            thickness,
            fill_color: fill_color.map(Into::into),
            outline_color: outline_color.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "CircleAnnotation(timestamp={:?}, position={:?}, diameter={:?}, thickness={:?}, fill_color={:?}, outline_color={:?})",
            self.0.timestamp,
            self.0.position,
            self.0.diameter,
            self.0.thickness,
            self.0.fill_color,
            self.0.outline_color,
        )
    }
    /// Returns the CircleAnnotation schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::CircleAnnotation::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the CircleAnnotation as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<CircleAnnotation> for foxglove::schemas::CircleAnnotation {
    fn from(value: CircleAnnotation) -> Self {
        value.0
    }
}

/// A color in RGBA format
///
/// :param r: Red value between 0 and 1
/// :param g: Green value between 0 and 1
/// :param b: Blue value between 0 and 1
/// :param a: Alpha value between 0 and 1
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/color
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct Color(pub(crate) foxglove::schemas::Color);
#[pymethods]
impl Color {
    #[new]
    #[pyo3(signature = (*, r=0.0, g=0.0, b=0.0, a=0.0) )]
    fn new(r: f64, g: f64, b: f64, a: f64) -> Self {
        Self(foxglove::schemas::Color { r, g, b, a })
    }
    fn __repr__(&self) -> String {
        format!(
            "Color(r={:?}, g={:?}, b={:?}, a={:?})",
            self.0.r, self.0.g, self.0.b, self.0.a,
        )
    }
    /// Returns the Color schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::Color::get_schema().unwrap().into()
    }
    /// Encodes the Color as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<Color> for foxglove::schemas::Color {
    fn from(value: Color) -> Self {
        value.0
    }
}

/// A compressed image
///
/// :param timestamp: Timestamp of image
/// :param frame_id: Frame of reference for the image. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
/// :param data: Compressed image data
/// :param format: Image format
///     
///     Supported values: `jpeg`, `png`, `webp`, `avif`
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/compressed-image
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct CompressedImage(pub(crate) foxglove::schemas::CompressedImage);
#[pymethods]
impl CompressedImage {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", data=None, format="") )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        data: Option<Bound<'_, PyBytes>>,
        format: &str,
    ) -> Self {
        Self(foxglove::schemas::CompressedImage {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            data: data
                .map(|x| Bytes::copy_from_slice(x.as_bytes()))
                .unwrap_or_default(),
            format: format.to_string(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "CompressedImage(timestamp={:?}, frame_id={:?}, data={:?}, format={:?})",
            self.0.timestamp, self.0.frame_id, self.0.data, self.0.format,
        )
    }
    /// Returns the CompressedImage schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::CompressedImage::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the CompressedImage as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<CompressedImage> for foxglove::schemas::CompressedImage {
    fn from(value: CompressedImage) -> Self {
        value.0
    }
}

/// A single frame of a compressed video bitstream
///
/// :param timestamp: Timestamp of video frame
/// :param frame_id: Frame of reference for the video.
///     
///     The origin of the frame is the optical center of the camera. +x points to the right in the video, +y points down, and +z points into the plane of the video.
/// :param data: Compressed video frame data.
///     
///     For packet-based video codecs this data must begin and end on packet boundaries (no partial packets), and must contain enough video packets to decode exactly one image (either a keyframe or delta frame). Note: Foxglove does not support video streams that include B frames because they require lookahead.
///     
///     Specifically, the requirements for different `format` values are:
///     
///     - `h264`
///       - Use Annex B formatted data
///       - Each CompressedVideo message should contain enough NAL units to decode exactly one video frame
///       - Each message containing a key frame (IDR) must also include a SPS NAL unit
///     
///     - `h265` (HEVC)
///       - Use Annex B formatted data
///       - Each CompressedVideo message should contain enough NAL units to decode exactly one video frame
///       - Each message containing a key frame (IRAP) must also include relevant VPS/SPS/PPS NAL units
///     
///     - `vp9`
///       - Each CompressedVideo message should contain exactly one video frame
///     
///     - `av1`
///       - Use the "Low overhead bitstream format" (section 5.2)
///       - Each CompressedVideo message should contain enough OBUs to decode exactly one video frame
///       - Each message containing a key frame must also include a Sequence Header OBU
/// :param format: Video format.
///     
///     Supported values: `h264`, `h265`, `vp9`, `av1`.
///     
///     Note: compressed video support is subject to hardware limitations and patent licensing, so not all encodings may be supported on all platforms. See more about `H.265 support <https://caniuse.com/hevc>`__, `VP9 support <https://caniuse.com/webm>`__, and `AV1 support <https://caniuse.com/av1>`__.
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/compressed-video
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct CompressedVideo(pub(crate) foxglove::schemas::CompressedVideo);
#[pymethods]
impl CompressedVideo {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", data=None, format="") )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        data: Option<Bound<'_, PyBytes>>,
        format: &str,
    ) -> Self {
        Self(foxglove::schemas::CompressedVideo {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            data: data
                .map(|x| Bytes::copy_from_slice(x.as_bytes()))
                .unwrap_or_default(),
            format: format.to_string(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "CompressedVideo(timestamp={:?}, frame_id={:?}, data={:?}, format={:?})",
            self.0.timestamp, self.0.frame_id, self.0.data, self.0.format,
        )
    }
    /// Returns the CompressedVideo schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::CompressedVideo::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the CompressedVideo as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<CompressedVideo> for foxglove::schemas::CompressedVideo {
    fn from(value: CompressedVideo) -> Self {
        value.0
    }
}

/// A primitive representing a cylinder, elliptic cylinder, or truncated cone
///
/// :param pose: Position of the center of the cylinder and orientation of the cylinder. The flat face(s) are perpendicular to the z-axis.
/// :param size: Size of the cylinder's bounding box
/// :param bottom_scale: 0-1, ratio of the diameter of the cylinder's bottom face (min z) to the bottom of the bounding box
/// :param top_scale: 0-1, ratio of the diameter of the cylinder's top face (max z) to the top of the bounding box
/// :param color: Color of the cylinder
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/cylinder-primitive
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct CylinderPrimitive(pub(crate) foxglove::schemas::CylinderPrimitive);
#[pymethods]
impl CylinderPrimitive {
    #[new]
    #[pyo3(signature = (*, pose=None, size=None, bottom_scale=0.0, top_scale=0.0, color=None) )]
    fn new(
        pose: Option<Pose>,
        size: Option<Vector3>,
        bottom_scale: f64,
        top_scale: f64,
        color: Option<Color>,
    ) -> Self {
        Self(foxglove::schemas::CylinderPrimitive {
            pose: pose.map(Into::into),
            size: size.map(Into::into),
            bottom_scale,
            top_scale,
            color: color.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "CylinderPrimitive(pose={:?}, size={:?}, bottom_scale={:?}, top_scale={:?}, color={:?})",
            self.0.pose,
            self.0.size,
            self.0.bottom_scale,
            self.0.top_scale,
            self.0.color,
        )
    }
    /// Returns the CylinderPrimitive schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::CylinderPrimitive::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the CylinderPrimitive as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<CylinderPrimitive> for foxglove::schemas::CylinderPrimitive {
    fn from(value: CylinderPrimitive) -> Self {
        value.0
    }
}

/// A primitive representing a cube or rectangular prism
///
/// :param pose: Position of the center of the cube and orientation of the cube
/// :param size: Size of the cube along each axis
/// :param color: Color of the cube
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/cube-primitive
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct CubePrimitive(pub(crate) foxglove::schemas::CubePrimitive);
#[pymethods]
impl CubePrimitive {
    #[new]
    #[pyo3(signature = (*, pose=None, size=None, color=None) )]
    fn new(pose: Option<Pose>, size: Option<Vector3>, color: Option<Color>) -> Self {
        Self(foxglove::schemas::CubePrimitive {
            pose: pose.map(Into::into),
            size: size.map(Into::into),
            color: color.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "CubePrimitive(pose={:?}, size={:?}, color={:?})",
            self.0.pose, self.0.size, self.0.color,
        )
    }
    /// Returns the CubePrimitive schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::CubePrimitive::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the CubePrimitive as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<CubePrimitive> for foxglove::schemas::CubePrimitive {
    fn from(value: CubePrimitive) -> Self {
        value.0
    }
}

/// A transform between two reference frames in 3D space
///
/// :param timestamp: Timestamp of transform
/// :param parent_frame_id: Name of the parent frame
/// :param child_frame_id: Name of the child frame
/// :param translation: Translation component of the transform
/// :param rotation: Rotation component of the transform
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/frame-transform
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct FrameTransform(pub(crate) foxglove::schemas::FrameTransform);
#[pymethods]
impl FrameTransform {
    #[new]
    #[pyo3(signature = (*, timestamp=None, parent_frame_id="", child_frame_id="", translation=None, rotation=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        parent_frame_id: &str,
        child_frame_id: &str,
        translation: Option<Vector3>,
        rotation: Option<Quaternion>,
    ) -> Self {
        Self(foxglove::schemas::FrameTransform {
            timestamp: timestamp.map(Into::into),
            parent_frame_id: parent_frame_id.to_string(),
            child_frame_id: child_frame_id.to_string(),
            translation: translation.map(Into::into),
            rotation: rotation.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "FrameTransform(timestamp={:?}, parent_frame_id={:?}, child_frame_id={:?}, translation={:?}, rotation={:?})",
            self.0.timestamp,
            self.0.parent_frame_id,
            self.0.child_frame_id,
            self.0.translation,
            self.0.rotation,
        )
    }
    /// Returns the FrameTransform schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::FrameTransform::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the FrameTransform as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<FrameTransform> for foxglove::schemas::FrameTransform {
    fn from(value: FrameTransform) -> Self {
        value.0
    }
}

/// An array of FrameTransform messages
///
/// :param transforms: Array of transforms
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/frame-transforms
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct FrameTransforms(pub(crate) foxglove::schemas::FrameTransforms);
#[pymethods]
impl FrameTransforms {
    #[new]
    #[pyo3(signature = (*, transforms=None) )]
    fn new(transforms: Option<Vec<FrameTransform>>) -> Self {
        Self(foxglove::schemas::FrameTransforms {
            transforms: transforms
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
        })
    }
    fn __repr__(&self) -> String {
        format!("FrameTransforms(transforms={:?})", self.0.transforms,)
    }
    /// Returns the FrameTransforms schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::FrameTransforms::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the FrameTransforms as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<FrameTransforms> for foxglove::schemas::FrameTransforms {
    fn from(value: FrameTransforms) -> Self {
        value.0
    }
}

/// GeoJSON data for annotating maps
///
/// :param geojson: GeoJSON data encoded as a UTF-8 string
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/geo-json
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct GeoJson(pub(crate) foxglove::schemas::GeoJson);
#[pymethods]
impl GeoJson {
    #[new]
    #[pyo3(signature = (*, geojson="") )]
    fn new(geojson: &str) -> Self {
        Self(foxglove::schemas::GeoJson {
            geojson: geojson.to_string(),
        })
    }
    fn __repr__(&self) -> String {
        format!("GeoJson(geojson={:?})", self.0.geojson,)
    }
    /// Returns the GeoJson schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::GeoJson::get_schema().unwrap().into()
    }
    /// Encodes the GeoJson as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<GeoJson> for foxglove::schemas::GeoJson {
    fn from(value: GeoJson) -> Self {
        value.0
    }
}

/// A 2D grid of data
///
/// :param timestamp: Timestamp of grid
/// :param frame_id: Frame of reference
/// :param pose: Origin of grid's corner relative to frame of reference; grid is positioned in the x-y plane relative to this origin
/// :param column_count: Number of grid columns
/// :param cell_size: Size of single grid cell along x and y axes, relative to `pose`
/// :param row_stride: Number of bytes between rows in `data`
/// :param cell_stride: Number of bytes between cells within a row in `data`
/// :param fields: Fields in `data`. S`red`, `green`, `blue`, and `alpha` are optional for customizing the grid's color.
///     To enable RGB color visualization in the `3D panel <https://docs.foxglove.dev/docs/visualization/panels/3d#rgba-separate-fields-color-mode>`__, include **all four** of these fields in your `fields` array:
///     
///     - `red` - Red channel value
///     - `green` - Green channel value
///     - `blue` - Blue channel value
///     - `alpha` - Alpha/transparency channel value
///     
///     **note:** All four fields must be present with these exact names for RGB visualization to work. The order of fields doesn't matter, but the names must match exactly.
///     
///     Recommended type: `UINT8` (0-255 range) for standard 8-bit color channels.
///     
///     Example field definitions:
///     
///     **RGB color only:**
///     
///     ::
///
///         fields: [
///          { name: "red", offset: 0, type: NumericType.UINT8 },
///          { name: "green", offset: 1, type: NumericType.UINT8 },
///          { name: "blue", offset: 2, type: NumericType.UINT8 },
///          { name: "alpha", offset: 3, type: NumericType.UINT8 },
///         ];
///     
///     **RGB color with elevation (for 3D terrain visualization):**
///     
///     ::
///
///         fields: [
///          { name: "red", offset: 0, type: NumericType.UINT8 },
///          { name: "green", offset: 1, type: NumericType.UINT8 },
///          { name: "blue", offset: 2, type: NumericType.UINT8 },
///          { name: "alpha", offset: 3, type: NumericType.UINT8 },
///          { name: "elevation", offset: 4, type: NumericType.FLOAT32 },
///         ];
///     
///     When these fields are present, the 3D panel will offer additional "Color Mode" options including "RGBA (separate fields)" to visualize the RGB data directly. For elevation visualization, set the "Elevation field" to your elevation layer name.
/// :param data: Grid cell data, interpreted using `fields`, in row-major (y-major) order.
///     For the data element starting at byte offset i, the coordinates of its corner closest to the origin will be:
///     
///     - y = i / row_stride * cell_size.y
///     - x = (i % row_stride) / cell_stride * cell_size.x
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/grid
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct Grid(pub(crate) foxglove::schemas::Grid);
#[pymethods]
impl Grid {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", pose=None, column_count=0, cell_size=None, row_stride=0, cell_stride=0, fields=None, data=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        pose: Option<Pose>,
        column_count: u32,
        cell_size: Option<Vector2>,
        row_stride: u32,
        cell_stride: u32,
        fields: Option<Vec<PackedElementField>>,
        data: Option<Bound<'_, PyBytes>>,
    ) -> Self {
        Self(foxglove::schemas::Grid {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            pose: pose.map(Into::into),
            column_count,
            cell_size: cell_size.map(Into::into),
            row_stride,
            cell_stride,
            fields: fields
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            data: data
                .map(|x| Bytes::copy_from_slice(x.as_bytes()))
                .unwrap_or_default(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "Grid(timestamp={:?}, frame_id={:?}, pose={:?}, column_count={:?}, cell_size={:?}, row_stride={:?}, cell_stride={:?}, fields={:?}, data={:?})",
            self.0.timestamp,
            self.0.frame_id,
            self.0.pose,
            self.0.column_count,
            self.0.cell_size,
            self.0.row_stride,
            self.0.cell_stride,
            self.0.fields,
            self.0.data,
        )
    }
    /// Returns the Grid schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::Grid::get_schema().unwrap().into()
    }
    /// Encodes the Grid as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<Grid> for foxglove::schemas::Grid {
    fn from(value: Grid) -> Self {
        value.0
    }
}

/// A 3D grid of data
///
/// :param timestamp: Timestamp of grid
/// :param frame_id: Frame of reference
/// :param pose: Origin of grid's corner relative to frame of reference
/// :param row_count: Number of grid rows
/// :param column_count: Number of grid columns
/// :param cell_size: Size of single grid cell along x, y, and z axes, relative to `pose`
/// :param slice_stride: Number of bytes between depth slices in `data`
/// :param row_stride: Number of bytes between rows in `data`
/// :param cell_stride: Number of bytes between cells within a row in `data`
/// :param fields: Fields in `data`. `red`, `green`, `blue`, and `alpha` are optional for customizing the grid's color.
/// :param data: Grid cell data, interpreted using `fields`, in depth-major, row-major (Z-Y-X) order.
///     For the data element starting at byte offset i, the coordinates of its corner closest to the origin will be:
///     
///     - z = i / slice_stride * cell_size.z
///     - y = (i % slice_stride) / row_stride * cell_size.y
///     - x = (i % row_stride) / cell_stride * cell_size.x
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/voxel-grid
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct VoxelGrid(pub(crate) foxglove::schemas::VoxelGrid);
#[pymethods]
impl VoxelGrid {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", pose=None, row_count=0, column_count=0, cell_size=None, slice_stride=0, row_stride=0, cell_stride=0, fields=None, data=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        pose: Option<Pose>,
        row_count: u32,
        column_count: u32,
        cell_size: Option<Vector3>,
        slice_stride: u32,
        row_stride: u32,
        cell_stride: u32,
        fields: Option<Vec<PackedElementField>>,
        data: Option<Bound<'_, PyBytes>>,
    ) -> Self {
        Self(foxglove::schemas::VoxelGrid {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            pose: pose.map(Into::into),
            row_count,
            column_count,
            cell_size: cell_size.map(Into::into),
            slice_stride,
            row_stride,
            cell_stride,
            fields: fields
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            data: data
                .map(|x| Bytes::copy_from_slice(x.as_bytes()))
                .unwrap_or_default(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "VoxelGrid(timestamp={:?}, frame_id={:?}, pose={:?}, row_count={:?}, column_count={:?}, cell_size={:?}, slice_stride={:?}, row_stride={:?}, cell_stride={:?}, fields={:?}, data={:?})",
            self.0.timestamp,
            self.0.frame_id,
            self.0.pose,
            self.0.row_count,
            self.0.column_count,
            self.0.cell_size,
            self.0.slice_stride,
            self.0.row_stride,
            self.0.cell_stride,
            self.0.fields,
            self.0.data,
        )
    }
    /// Returns the VoxelGrid schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::VoxelGrid::get_schema().unwrap().into()
    }
    /// Encodes the VoxelGrid as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<VoxelGrid> for foxglove::schemas::VoxelGrid {
    fn from(value: VoxelGrid) -> Self {
        value.0
    }
}

/// Array of annotations for a 2D image
///
/// :param circles: Circle annotations
/// :param points: Points annotations
/// :param texts: Text annotations
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/image-annotations
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct ImageAnnotations(pub(crate) foxglove::schemas::ImageAnnotations);
#[pymethods]
impl ImageAnnotations {
    #[new]
    #[pyo3(signature = (*, circles=None, points=None, texts=None) )]
    fn new(
        circles: Option<Vec<CircleAnnotation>>,
        points: Option<Vec<PointsAnnotation>>,
        texts: Option<Vec<TextAnnotation>>,
    ) -> Self {
        Self(foxglove::schemas::ImageAnnotations {
            circles: circles
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            points: points
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            texts: texts
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "ImageAnnotations(circles={:?}, points={:?}, texts={:?})",
            self.0.circles, self.0.points, self.0.texts,
        )
    }
    /// Returns the ImageAnnotations schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::ImageAnnotations::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the ImageAnnotations as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<ImageAnnotations> for foxglove::schemas::ImageAnnotations {
    fn from(value: ImageAnnotations) -> Self {
        value.0
    }
}

/// A key with its associated value
///
/// :param key: Key
/// :param value: Value
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/key-value-pair
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct KeyValuePair(pub(crate) foxglove::schemas::KeyValuePair);
#[pymethods]
impl KeyValuePair {
    #[new]
    #[pyo3(signature = (*, key="", value="") )]
    fn new(key: &str, value: &str) -> Self {
        Self(foxglove::schemas::KeyValuePair {
            key: key.to_string(),
            value: value.to_string(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "KeyValuePair(key={:?}, value={:?})",
            self.0.key, self.0.value,
        )
    }
    /// Returns the KeyValuePair schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::KeyValuePair::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the KeyValuePair as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<KeyValuePair> for foxglove::schemas::KeyValuePair {
    fn from(value: KeyValuePair) -> Self {
        value.0
    }
}

/// A single scan from a planar laser range-finder
///
/// :param timestamp: Timestamp of scan
/// :param frame_id: Frame of reference
/// :param pose: Origin of scan relative to frame of reference; points are positioned in the x-y plane relative to this origin; angles are interpreted as counterclockwise rotations around the z axis with 0 rad being in the +x direction
/// :param start_angle: Bearing of first point, in radians
/// :param end_angle: Bearing of last point, in radians
/// :param ranges: Distance of detections from origin; assumed to be at equally-spaced angles between `start_angle` and `end_angle`
/// :param intensities: Intensity of detections
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/laser-scan
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct LaserScan(pub(crate) foxglove::schemas::LaserScan);
#[pymethods]
impl LaserScan {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", pose=None, start_angle=0.0, end_angle=0.0, ranges=None, intensities=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        pose: Option<Pose>,
        start_angle: f64,
        end_angle: f64,
        ranges: Option<Vec<f64>>,
        intensities: Option<Vec<f64>>,
    ) -> Self {
        Self(foxglove::schemas::LaserScan {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            pose: pose.map(Into::into),
            start_angle,
            end_angle,
            ranges: ranges.unwrap_or_default(),
            intensities: intensities.unwrap_or_default(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "LaserScan(timestamp={:?}, frame_id={:?}, pose={:?}, start_angle={:?}, end_angle={:?}, ranges={:?}, intensities={:?})",
            self.0.timestamp,
            self.0.frame_id,
            self.0.pose,
            self.0.start_angle,
            self.0.end_angle,
            self.0.ranges,
            self.0.intensities,
        )
    }
    /// Returns the LaserScan schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::LaserScan::get_schema().unwrap().into()
    }
    /// Encodes the LaserScan as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<LaserScan> for foxglove::schemas::LaserScan {
    fn from(value: LaserScan) -> Self {
        value.0
    }
}

/// A primitive representing a series of points connected by lines
///
/// :param type: Drawing primitive to use for lines
/// :param pose: Origin of lines relative to reference frame
/// :param thickness: Line thickness
/// :param scale_invariant: Indicates whether `thickness` is a fixed size in screen pixels (true), or specified in world coordinates and scales with distance from the camera (false)
/// :param points: Points along the line
/// :param color: Solid color to use for the whole line. Ignored if `colors` is non-empty.
/// :param colors: Per-point colors (if non-empty, must have the same length as `points`).
/// :param indices: Indices into the `points` and `colors` attribute arrays, which can be used to avoid duplicating attribute data.
///     
///     If omitted or empty, indexing will not be used. This default behavior is equivalent to specifying [0, 1, ..., N-1] for the indices (where N is the number of `points` provided).
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/line-primitive
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct LinePrimitive(pub(crate) foxglove::schemas::LinePrimitive);
#[pymethods]
impl LinePrimitive {
    #[new]
    #[pyo3(signature = (*, r#type=LinePrimitiveLineType::LineStrip, pose=None, thickness=0.0, scale_invariant=false, points=None, color=None, colors=None, indices=None) )]
    fn new(
        r#type: LinePrimitiveLineType,
        pose: Option<Pose>,
        thickness: f64,
        scale_invariant: bool,
        points: Option<Vec<Point3>>,
        color: Option<Color>,
        colors: Option<Vec<Color>>,
        indices: Option<Vec<u32>>,
    ) -> Self {
        Self(foxglove::schemas::LinePrimitive {
            r#type: r#type as i32,
            pose: pose.map(Into::into),
            thickness,
            scale_invariant,
            points: points
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            color: color.map(Into::into),
            colors: colors
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            indices: indices.unwrap_or_default(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "LinePrimitive(r#type={:?}, pose={:?}, thickness={:?}, scale_invariant={:?}, points={:?}, color={:?}, colors={:?}, indices={:?})",
            self.0.r#type,
            self.0.pose,
            self.0.thickness,
            self.0.scale_invariant,
            self.0.points,
            self.0.color,
            self.0.colors,
            self.0.indices,
        )
    }
    /// Returns the LinePrimitive schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::LinePrimitive::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the LinePrimitive as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<LinePrimitive> for foxglove::schemas::LinePrimitive {
    fn from(value: LinePrimitive) -> Self {
        value.0
    }
}

/// A navigation satellite fix for any Global Navigation Satellite System
///
/// :param timestamp: Timestamp of the message
/// :param frame_id: Frame for the sensor. Latitude and longitude readings are at the origin of the frame.
/// :param latitude: Latitude in degrees
/// :param longitude: Longitude in degrees
/// :param altitude: Altitude in meters
/// :param position_covariance: Position covariance (m^2) defined relative to a tangential plane through the reported position. The components are East, North, and Up (ENU), in row-major order.
/// :param position_covariance_type: If `position_covariance` is available, `position_covariance_type` must be set to indicate the type of covariance.
/// :param color: Color used to visualize the location
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/location-fix
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct LocationFix(pub(crate) foxglove::schemas::LocationFix);
#[pymethods]
impl LocationFix {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", latitude=0.0, longitude=0.0, altitude=0.0, position_covariance=None, position_covariance_type=LocationFixPositionCovarianceType::Unknown, color=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        latitude: f64,
        longitude: f64,
        altitude: f64,
        position_covariance: Option<Vec<f64>>,
        position_covariance_type: LocationFixPositionCovarianceType,
        color: Option<Color>,
    ) -> Self {
        Self(foxglove::schemas::LocationFix {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            latitude,
            longitude,
            altitude,
            position_covariance: position_covariance.unwrap_or_default(),
            position_covariance_type: position_covariance_type as i32,
            color: color.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "LocationFix(timestamp={:?}, frame_id={:?}, latitude={:?}, longitude={:?}, altitude={:?}, position_covariance={:?}, position_covariance_type={:?}, color={:?})",
            self.0.timestamp,
            self.0.frame_id,
            self.0.latitude,
            self.0.longitude,
            self.0.altitude,
            self.0.position_covariance,
            self.0.position_covariance_type,
            self.0.color,
        )
    }
    /// Returns the LocationFix schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::LocationFix::get_schema().unwrap().into()
    }
    /// Encodes the LocationFix as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<LocationFix> for foxglove::schemas::LocationFix {
    fn from(value: LocationFix) -> Self {
        value.0
    }
}

/// A group of LocationFix messages
///
/// :param fixes: An array of location fixes
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/location-fixes
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct LocationFixes(pub(crate) foxglove::schemas::LocationFixes);
#[pymethods]
impl LocationFixes {
    #[new]
    #[pyo3(signature = (*, fixes=None) )]
    fn new(fixes: Option<Vec<LocationFix>>) -> Self {
        Self(foxglove::schemas::LocationFixes {
            fixes: fixes
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
        })
    }
    fn __repr__(&self) -> String {
        format!("LocationFixes(fixes={:?})", self.0.fixes,)
    }
    /// Returns the LocationFixes schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::LocationFixes::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the LocationFixes as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<LocationFixes> for foxglove::schemas::LocationFixes {
    fn from(value: LocationFixes) -> Self {
        value.0
    }
}

/// A log message
///
/// :param timestamp: Timestamp of log message
/// :param level: Log level
/// :param message: Log message
/// :param name: Process or node name
/// :param file: Filename
/// :param line: Line number in the file
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/log
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct Log(pub(crate) foxglove::schemas::Log);
#[pymethods]
impl Log {
    #[new]
    #[pyo3(signature = (*, timestamp=None, level=LogLevel::Unknown, message="", name="", file="", line=0) )]
    fn new(
        timestamp: Option<Timestamp>,
        level: LogLevel,
        message: &str,
        name: &str,
        file: &str,
        line: u32,
    ) -> Self {
        Self(foxglove::schemas::Log {
            timestamp: timestamp.map(Into::into),
            level: level as i32,
            message: message.to_string(),
            name: name.to_string(),
            file: file.to_string(),
            line,
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "Log(timestamp={:?}, level={:?}, message={:?}, name={:?}, file={:?}, line={:?})",
            self.0.timestamp, self.0.level, self.0.message, self.0.name, self.0.file, self.0.line,
        )
    }
    /// Returns the Log schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::Log::get_schema().unwrap().into()
    }
    /// Encodes the Log as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<Log> for foxglove::schemas::Log {
    fn from(value: Log) -> Self {
        value.0
    }
}

/// Command to remove previously published entities
///
/// :param timestamp: Timestamp of the deletion. Only matching entities earlier than this timestamp will be deleted.
/// :param type: Type of deletion action to perform
/// :param id: Identifier which must match if `type` is `MATCHING_ID`.
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/scene-entity-deletion
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct SceneEntityDeletion(pub(crate) foxglove::schemas::SceneEntityDeletion);
#[pymethods]
impl SceneEntityDeletion {
    #[new]
    #[pyo3(signature = (*, timestamp=None, r#type=SceneEntityDeletionType::MatchingId, id="") )]
    fn new(timestamp: Option<Timestamp>, r#type: SceneEntityDeletionType, id: &str) -> Self {
        Self(foxglove::schemas::SceneEntityDeletion {
            timestamp: timestamp.map(Into::into),
            r#type: r#type as i32,
            id: id.to_string(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "SceneEntityDeletion(timestamp={:?}, r#type={:?}, id={:?})",
            self.0.timestamp, self.0.r#type, self.0.id,
        )
    }
    /// Returns the SceneEntityDeletion schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::SceneEntityDeletion::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the SceneEntityDeletion as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<SceneEntityDeletion> for foxglove::schemas::SceneEntityDeletion {
    fn from(value: SceneEntityDeletion) -> Self {
        value.0
    }
}

/// A visual element in a 3D scene. An entity may be composed of multiple primitives which all share the same frame of reference.
///
/// :param timestamp: Timestamp of the entity
/// :param frame_id: Frame of reference
/// :param id: Identifier for the entity. A entity will replace any prior entity on the same topic with the same `id`.
/// :param lifetime: Length of time (relative to `timestamp`) after which the entity should be automatically removed. Zero value indicates the entity should remain visible until it is replaced or deleted.
/// :param frame_locked: Whether the entity should keep its location in the fixed frame (false) or follow the frame specified in `frame_id` as it moves relative to the fixed frame (true)
/// :param metadata: Additional user-provided metadata associated with the entity. Keys must be unique.
/// :param arrows: Arrow primitives
/// :param cubes: Cube primitives
/// :param spheres: Sphere primitives
/// :param cylinders: Cylinder primitives
/// :param lines: Line primitives
/// :param triangles: Triangle list primitives
/// :param texts: Text primitives
/// :param models: Model primitives
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/scene-entity
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct SceneEntity(pub(crate) foxglove::schemas::SceneEntity);
#[pymethods]
impl SceneEntity {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", id="", lifetime=None, frame_locked=false, metadata=None, arrows=None, cubes=None, spheres=None, cylinders=None, lines=None, triangles=None, texts=None, models=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        id: &str,
        lifetime: Option<Duration>,
        frame_locked: bool,
        metadata: Option<Vec<KeyValuePair>>,
        arrows: Option<Vec<ArrowPrimitive>>,
        cubes: Option<Vec<CubePrimitive>>,
        spheres: Option<Vec<SpherePrimitive>>,
        cylinders: Option<Vec<CylinderPrimitive>>,
        lines: Option<Vec<LinePrimitive>>,
        triangles: Option<Vec<TriangleListPrimitive>>,
        texts: Option<Vec<TextPrimitive>>,
        models: Option<Vec<ModelPrimitive>>,
    ) -> Self {
        Self(foxglove::schemas::SceneEntity {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            id: id.to_string(),
            lifetime: lifetime.map(Into::into),
            frame_locked,
            metadata: metadata
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            arrows: arrows
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            cubes: cubes
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            spheres: spheres
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            cylinders: cylinders
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            lines: lines
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            triangles: triangles
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            texts: texts
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            models: models
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "SceneEntity(timestamp={:?}, frame_id={:?}, id={:?}, lifetime={:?}, frame_locked={:?}, metadata={:?}, arrows={:?}, cubes={:?}, spheres={:?}, cylinders={:?}, lines={:?}, triangles={:?}, texts={:?}, models={:?})",
            self.0.timestamp,
            self.0.frame_id,
            self.0.id,
            self.0.lifetime,
            self.0.frame_locked,
            self.0.metadata,
            self.0.arrows,
            self.0.cubes,
            self.0.spheres,
            self.0.cylinders,
            self.0.lines,
            self.0.triangles,
            self.0.texts,
            self.0.models,
        )
    }
    /// Returns the SceneEntity schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::SceneEntity::get_schema().unwrap().into()
    }
    /// Encodes the SceneEntity as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<SceneEntity> for foxglove::schemas::SceneEntity {
    fn from(value: SceneEntity) -> Self {
        value.0
    }
}

/// An update to the entities displayed in a 3D scene
///
/// :param deletions: Scene entities to delete
/// :param entities: Scene entities to add or replace
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/scene-update
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct SceneUpdate(pub(crate) foxglove::schemas::SceneUpdate);
#[pymethods]
impl SceneUpdate {
    #[new]
    #[pyo3(signature = (*, deletions=None, entities=None) )]
    fn new(
        deletions: Option<Vec<SceneEntityDeletion>>,
        entities: Option<Vec<SceneEntity>>,
    ) -> Self {
        Self(foxglove::schemas::SceneUpdate {
            deletions: deletions
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            entities: entities
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "SceneUpdate(deletions={:?}, entities={:?})",
            self.0.deletions, self.0.entities,
        )
    }
    /// Returns the SceneUpdate schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::SceneUpdate::get_schema().unwrap().into()
    }
    /// Encodes the SceneUpdate as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<SceneUpdate> for foxglove::schemas::SceneUpdate {
    fn from(value: SceneUpdate) -> Self {
        value.0
    }
}

/// A primitive representing a 3D model file loaded from an external URL or embedded data
///
/// :param pose: Origin of model relative to reference frame
/// :param scale: Scale factor to apply to the model along each axis
/// :param color: Solid color to use for the whole model if `override_color` is true.
/// :param override_color: Whether to use the color specified in `color` instead of any materials embedded in the original model.
/// :param url: URL pointing to model file. One of `url` or `data` should be non-empty.
/// :param media_type: [Media type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) of embedded model (e.g. `model/gltf-binary`). Required if `data` is provided instead of `url`. Overrides the inferred media type if `url` is provided.
/// :param data: Embedded model. One of `url` or `data` should be non-empty. If `data` is non-empty, `media_type` must be set to indicate the type of the data.
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/model-primitive
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct ModelPrimitive(pub(crate) foxglove::schemas::ModelPrimitive);
#[pymethods]
impl ModelPrimitive {
    #[new]
    #[pyo3(signature = (*, pose=None, scale=None, color=None, override_color=false, url="", media_type="", data=None) )]
    fn new(
        pose: Option<Pose>,
        scale: Option<Vector3>,
        color: Option<Color>,
        override_color: bool,
        url: &str,
        media_type: &str,
        data: Option<Bound<'_, PyBytes>>,
    ) -> Self {
        Self(foxglove::schemas::ModelPrimitive {
            pose: pose.map(Into::into),
            scale: scale.map(Into::into),
            color: color.map(Into::into),
            override_color,
            url: url.to_string(),
            media_type: media_type.to_string(),
            data: data
                .map(|x| Bytes::copy_from_slice(x.as_bytes()))
                .unwrap_or_default(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "ModelPrimitive(pose={:?}, scale={:?}, color={:?}, override_color={:?}, url={:?}, media_type={:?}, data={:?})",
            self.0.pose,
            self.0.scale,
            self.0.color,
            self.0.override_color,
            self.0.url,
            self.0.media_type,
            self.0.data,
        )
    }
    /// Returns the ModelPrimitive schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::ModelPrimitive::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the ModelPrimitive as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<ModelPrimitive> for foxglove::schemas::ModelPrimitive {
    fn from(value: ModelPrimitive) -> Self {
        value.0
    }
}

/// A field present within each element in a byte array of packed elements.
///
/// :param name: Name of the field
/// :param offset: Byte offset from start of data buffer
/// :param type: Type of data in the field. Integers are stored using little-endian byte order.
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/packed-element-field
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct PackedElementField(pub(crate) foxglove::schemas::PackedElementField);
#[pymethods]
impl PackedElementField {
    #[new]
    #[pyo3(signature = (*, name="", offset=0, r#type=PackedElementFieldNumericType::Unknown) )]
    fn new(name: &str, offset: u32, r#type: PackedElementFieldNumericType) -> Self {
        Self(foxglove::schemas::PackedElementField {
            name: name.to_string(),
            offset,
            r#type: r#type as i32,
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "PackedElementField(name={:?}, offset={:?}, r#type={:?})",
            self.0.name, self.0.offset, self.0.r#type,
        )
    }
    /// Returns the PackedElementField schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::PackedElementField::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the PackedElementField as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<PackedElementField> for foxglove::schemas::PackedElementField {
    fn from(value: PackedElementField) -> Self {
        value.0
    }
}

/// A point representing a position in 2D space
///
/// :param x: x coordinate position
/// :param y: y coordinate position
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/point2
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct Point2(pub(crate) foxglove::schemas::Point2);
#[pymethods]
impl Point2 {
    #[new]
    #[pyo3(signature = (*, x=0.0, y=0.0) )]
    fn new(x: f64, y: f64) -> Self {
        Self(foxglove::schemas::Point2 { x, y })
    }
    fn __repr__(&self) -> String {
        format!("Point2(x={:?}, y={:?})", self.0.x, self.0.y,)
    }
    /// Returns the Point2 schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::Point2::get_schema().unwrap().into()
    }
    /// Encodes the Point2 as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<Point2> for foxglove::schemas::Point2 {
    fn from(value: Point2) -> Self {
        value.0
    }
}

/// A point representing a position in 3D space
///
/// :param x: x coordinate position
/// :param y: y coordinate position
/// :param z: z coordinate position
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/point3
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct Point3(pub(crate) foxglove::schemas::Point3);
#[pymethods]
impl Point3 {
    #[new]
    #[pyo3(signature = (*, x=0.0, y=0.0, z=0.0) )]
    fn new(x: f64, y: f64, z: f64) -> Self {
        Self(foxglove::schemas::Point3 { x, y, z })
    }
    fn __repr__(&self) -> String {
        format!(
            "Point3(x={:?}, y={:?}, z={:?})",
            self.0.x, self.0.y, self.0.z,
        )
    }
    /// Returns the Point3 schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::Point3::get_schema().unwrap().into()
    }
    /// Encodes the Point3 as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<Point3> for foxglove::schemas::Point3 {
    fn from(value: Point3) -> Self {
        value.0
    }
}

/// A collection of N-dimensional points, which may contain additional fields with information like normals, intensity, etc.
///
/// :param timestamp: Timestamp of point cloud
/// :param frame_id: Frame of reference
/// :param pose: The origin of the point cloud relative to the frame of reference
/// :param point_stride: Number of bytes between points in the `data`
/// :param fields: Fields in `data`. At least 2 coordinate fields from `x`, `y`, and `z` are required for each point's position; `red`, `green`, `blue`, and `alpha` are optional for customizing each point's color.
/// :param data: Point data, interpreted using `fields`
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/point-cloud
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct PointCloud(pub(crate) foxglove::schemas::PointCloud);
#[pymethods]
impl PointCloud {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", pose=None, point_stride=0, fields=None, data=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        pose: Option<Pose>,
        point_stride: u32,
        fields: Option<Vec<PackedElementField>>,
        data: Option<Bound<'_, PyBytes>>,
    ) -> Self {
        Self(foxglove::schemas::PointCloud {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            pose: pose.map(Into::into),
            point_stride,
            fields: fields
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            data: data
                .map(|x| Bytes::copy_from_slice(x.as_bytes()))
                .unwrap_or_default(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "PointCloud(timestamp={:?}, frame_id={:?}, pose={:?}, point_stride={:?}, fields={:?}, data={:?})",
            self.0.timestamp,
            self.0.frame_id,
            self.0.pose,
            self.0.point_stride,
            self.0.fields,
            self.0.data,
        )
    }
    /// Returns the PointCloud schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::PointCloud::get_schema().unwrap().into()
    }
    /// Encodes the PointCloud as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<PointCloud> for foxglove::schemas::PointCloud {
    fn from(value: PointCloud) -> Self {
        value.0
    }
}

/// An array of points on a 2D image
///
/// :param timestamp: Timestamp of annotation
/// :param type: Type of points annotation to draw
/// :param points: Points in 2D image coordinates (pixels).
///     These coordinates use the top-left corner of the top-left pixel of the image as the origin.
/// :param outline_color: Outline color
/// :param outline_colors: Per-point colors, if `type` is `POINTS`, or per-segment stroke colors, if `type` is `LINE_LIST`, `LINE_STRIP` or `LINE_LOOP`.
/// :param fill_color: Fill color
/// :param thickness: Stroke thickness in pixels
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/points-annotation
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct PointsAnnotation(pub(crate) foxglove::schemas::PointsAnnotation);
#[pymethods]
impl PointsAnnotation {
    #[new]
    #[pyo3(signature = (*, timestamp=None, r#type=PointsAnnotationType::Unknown, points=None, outline_color=None, outline_colors=None, fill_color=None, thickness=0.0) )]
    fn new(
        timestamp: Option<Timestamp>,
        r#type: PointsAnnotationType,
        points: Option<Vec<Point2>>,
        outline_color: Option<Color>,
        outline_colors: Option<Vec<Color>>,
        fill_color: Option<Color>,
        thickness: f64,
    ) -> Self {
        Self(foxglove::schemas::PointsAnnotation {
            timestamp: timestamp.map(Into::into),
            r#type: r#type as i32,
            points: points
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            outline_color: outline_color.map(Into::into),
            outline_colors: outline_colors
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            fill_color: fill_color.map(Into::into),
            thickness,
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "PointsAnnotation(timestamp={:?}, r#type={:?}, points={:?}, outline_color={:?}, outline_colors={:?}, fill_color={:?}, thickness={:?})",
            self.0.timestamp,
            self.0.r#type,
            self.0.points,
            self.0.outline_color,
            self.0.outline_colors,
            self.0.fill_color,
            self.0.thickness,
        )
    }
    /// Returns the PointsAnnotation schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::PointsAnnotation::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the PointsAnnotation as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<PointsAnnotation> for foxglove::schemas::PointsAnnotation {
    fn from(value: PointsAnnotation) -> Self {
        value.0
    }
}

/// A position and orientation for an object or reference frame in 3D space
///
/// :param position: Point denoting position in 3D space
/// :param orientation: Quaternion denoting orientation in 3D space
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/pose
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct Pose(pub(crate) foxglove::schemas::Pose);
#[pymethods]
impl Pose {
    #[new]
    #[pyo3(signature = (*, position=None, orientation=None) )]
    fn new(position: Option<Vector3>, orientation: Option<Quaternion>) -> Self {
        Self(foxglove::schemas::Pose {
            position: position.map(Into::into),
            orientation: orientation.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "Pose(position={:?}, orientation={:?})",
            self.0.position, self.0.orientation,
        )
    }
    /// Returns the Pose schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::Pose::get_schema().unwrap().into()
    }
    /// Encodes the Pose as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<Pose> for foxglove::schemas::Pose {
    fn from(value: Pose) -> Self {
        value.0
    }
}

/// A timestamped pose for an object or reference frame in 3D space
///
/// :param timestamp: Timestamp of pose
/// :param frame_id: Frame of reference for pose position and orientation
/// :param pose: Pose in 3D space
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/pose-in-frame
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct PoseInFrame(pub(crate) foxglove::schemas::PoseInFrame);
#[pymethods]
impl PoseInFrame {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", pose=None) )]
    fn new(timestamp: Option<Timestamp>, frame_id: &str, pose: Option<Pose>) -> Self {
        Self(foxglove::schemas::PoseInFrame {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            pose: pose.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "PoseInFrame(timestamp={:?}, frame_id={:?}, pose={:?})",
            self.0.timestamp, self.0.frame_id, self.0.pose,
        )
    }
    /// Returns the PoseInFrame schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::PoseInFrame::get_schema().unwrap().into()
    }
    /// Encodes the PoseInFrame as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<PoseInFrame> for foxglove::schemas::PoseInFrame {
    fn from(value: PoseInFrame) -> Self {
        value.0
    }
}

/// An array of timestamped poses for an object or reference frame in 3D space
///
/// :param timestamp: Timestamp of pose
/// :param frame_id: Frame of reference for pose position and orientation
/// :param poses: Poses in 3D space
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/poses-in-frame
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct PosesInFrame(pub(crate) foxglove::schemas::PosesInFrame);
#[pymethods]
impl PosesInFrame {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", poses=None) )]
    fn new(timestamp: Option<Timestamp>, frame_id: &str, poses: Option<Vec<Pose>>) -> Self {
        Self(foxglove::schemas::PosesInFrame {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            poses: poses
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "PosesInFrame(timestamp={:?}, frame_id={:?}, poses={:?})",
            self.0.timestamp, self.0.frame_id, self.0.poses,
        )
    }
    /// Returns the PosesInFrame schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::PosesInFrame::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the PosesInFrame as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<PosesInFrame> for foxglove::schemas::PosesInFrame {
    fn from(value: PosesInFrame) -> Self {
        value.0
    }
}

/// A [quaternion](https://eater.net/quaternions) representing a rotation in 3D space
///
/// :param x: x value
/// :param y: y value
/// :param z: z value
/// :param w: w value
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/quaternion
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct Quaternion(pub(crate) foxglove::schemas::Quaternion);
#[pymethods]
impl Quaternion {
    #[new]
    #[pyo3(signature = (*, x=0.0, y=0.0, z=0.0, w=0.0) )]
    fn new(x: f64, y: f64, z: f64, w: f64) -> Self {
        Self(foxglove::schemas::Quaternion { x, y, z, w })
    }
    fn __repr__(&self) -> String {
        format!(
            "Quaternion(x={:?}, y={:?}, z={:?}, w={:?})",
            self.0.x, self.0.y, self.0.z, self.0.w,
        )
    }
    /// Returns the Quaternion schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::Quaternion::get_schema().unwrap().into()
    }
    /// Encodes the Quaternion as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<Quaternion> for foxglove::schemas::Quaternion {
    fn from(value: Quaternion) -> Self {
        value.0
    }
}

/// A single block of an audio bitstream
///
/// :param timestamp: Timestamp of the start of the audio block
/// :param data: Audio data. The samples in the data must be interleaved and little-endian
/// :param format: Audio format. Only 'pcm-s16' is currently supported
/// :param sample_rate: Sample rate in Hz
/// :param number_of_channels: Number of channels in the audio block
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/raw-audio
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct RawAudio(pub(crate) foxglove::schemas::RawAudio);
#[pymethods]
impl RawAudio {
    #[new]
    #[pyo3(signature = (*, timestamp=None, data=None, format="", sample_rate=0, number_of_channels=0) )]
    fn new(
        timestamp: Option<Timestamp>,
        data: Option<Bound<'_, PyBytes>>,
        format: &str,
        sample_rate: u32,
        number_of_channels: u32,
    ) -> Self {
        Self(foxglove::schemas::RawAudio {
            timestamp: timestamp.map(Into::into),
            data: data
                .map(|x| Bytes::copy_from_slice(x.as_bytes()))
                .unwrap_or_default(),
            format: format.to_string(),
            sample_rate,
            number_of_channels,
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "RawAudio(timestamp={:?}, data={:?}, format={:?}, sample_rate={:?}, number_of_channels={:?})",
            self.0.timestamp,
            self.0.data,
            self.0.format,
            self.0.sample_rate,
            self.0.number_of_channels,
        )
    }
    /// Returns the RawAudio schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::RawAudio::get_schema().unwrap().into()
    }
    /// Encodes the RawAudio as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<RawAudio> for foxglove::schemas::RawAudio {
    fn from(value: RawAudio) -> Self {
        value.0
    }
}

/// A raw image
///
/// :param timestamp: Timestamp of image
/// :param frame_id: Frame of reference for the image. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
/// :param width: Image width in pixels
/// :param height: Image height in pixels
/// :param encoding: Encoding of the raw image data. See the `data` field description for supported values.
/// :param step: Byte length of a single row. This is usually some multiple of `width` depending on the encoding, but can be greater to incorporate padding.
/// :param data: Raw image data.
///     
///     For each `encoding` value, the `data` field contains image pixel data serialized as follows:
///     
///     - `yuv422` or `uyvy`:
///       - Pixel colors are decomposed into `Y'UV <https://en.wikipedia.org/wiki/Y%E2%80%B2UV>`__ channels.
///       - Pixel channel values are represented as unsigned 8-bit integers.
///       - U and V values are shared between horizontal pairs of pixels. Each pair of output pixels is serialized as [U, Y1, V, Y2].
///       - `step` must be greater than or equal to `width` * 2.
///     - `yuv422_yuy2` or  `yuyv`:
///       - Pixel colors are decomposed into `Y'UV <https://en.wikipedia.org/wiki/Y%E2%80%B2UV>`__ channels.
///       - Pixel channel values are represented as unsigned 8-bit integers.
///       - U and V values are shared between horizontal pairs of pixels. Each pair of output pixels is encoded as [Y1, U, Y2, V].
///       - `step` must be greater than or equal to `width` * 2.
///     - `rgb8`:
///       - Pixel colors are decomposed into Red, Green, and Blue channels.
///       - Pixel channel values are represented as unsigned 8-bit integers.
///       - Each output pixel is serialized as [R, G, B].
///       - `step` must be greater than or equal to `width` * 3.
///     - `rgba8`:
///       - Pixel colors are decomposed into Red, Green, Blue, and Alpha channels.
///       - Pixel channel values are represented as unsigned 8-bit integers.
///       - Each output pixel is serialized as [R, G, B, Alpha].
///       - `step` must be greater than or equal to `width` * 4.
///     - `bgr8` or `8UC3`:
///       - Pixel colors are decomposed into Blue, Green, and Red channels.
///       - Pixel channel values are represented as unsigned 8-bit integers.
///       - Each output pixel is serialized as [B, G, R].
///       - `step` must be greater than or equal to `width` * 3.
///     - `bgra8`:
///       - Pixel colors are decomposed into Blue, Green, Red, and Alpha channels.
///       - Pixel channel values are represented as unsigned 8-bit integers.
///       - Each output pixel is encoded as [B, G, R, Alpha].
///       - `step` must be greater than or equal to `width` * 4.
///     - `32FC1`:
///       - Pixel brightness is represented as a single-channel, 32-bit little-endian IEEE 754 floating-point value, ranging from 0.0 (black) to 1.0 (white).
///       - `step` must be greater than or equal to `width` * 4.
///     - `bayer_rggb8`, `bayer_bggr8`, `bayer_gbrg8`, or `bayer_grbg8`:
///       - Pixel colors are decomposed into Red, Blue and Green channels.
///       - Pixel channel values are represented as unsigned 8-bit integers, and serialized in a 2x2 bayer filter pattern.
///       - The order of the four letters after `bayer_` determine the layout, so for `bayer_wxyz8` the pattern is:
///       ```plaintext
///       w | x
///       - + -
///       y | z
///       ```
///       - `step` must be greater than or equal to `width`.
///     - `mono8` or `8UC1`:
///       - Pixel brightness is represented as unsigned 8-bit integers.
///       - `step` must be greater than or equal to `width`.
///     - `mono16` or `16UC1`:
///       - Pixel brightness is represented as 16-bit unsigned little-endian integers. Rendering of these values is controlled in `Image panel color mode settings <https://docs.foxglove.dev/docs/visualization/panels/image#general>`__.
///       - `step` must be greater than or equal to `width` * 2.
///     
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/raw-image
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct RawImage(pub(crate) foxglove::schemas::RawImage);
#[pymethods]
impl RawImage {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", width=0, height=0, encoding="", step=0, data=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        width: u32,
        height: u32,
        encoding: &str,
        step: u32,
        data: Option<Bound<'_, PyBytes>>,
    ) -> Self {
        Self(foxglove::schemas::RawImage {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            width,
            height,
            encoding: encoding.to_string(),
            step,
            data: data
                .map(|x| Bytes::copy_from_slice(x.as_bytes()))
                .unwrap_or_default(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "RawImage(timestamp={:?}, frame_id={:?}, width={:?}, height={:?}, encoding={:?}, step={:?}, data={:?})",
            self.0.timestamp,
            self.0.frame_id,
            self.0.width,
            self.0.height,
            self.0.encoding,
            self.0.step,
            self.0.data,
        )
    }
    /// Returns the RawImage schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::RawImage::get_schema().unwrap().into()
    }
    /// Encodes the RawImage as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<RawImage> for foxglove::schemas::RawImage {
    fn from(value: RawImage) -> Self {
        value.0
    }
}

/// A primitive representing a sphere or ellipsoid
///
/// :param pose: Position of the center of the sphere and orientation of the sphere
/// :param size: Size (diameter) of the sphere along each axis
/// :param color: Color of the sphere
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/sphere-primitive
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct SpherePrimitive(pub(crate) foxglove::schemas::SpherePrimitive);
#[pymethods]
impl SpherePrimitive {
    #[new]
    #[pyo3(signature = (*, pose=None, size=None, color=None) )]
    fn new(pose: Option<Pose>, size: Option<Vector3>, color: Option<Color>) -> Self {
        Self(foxglove::schemas::SpherePrimitive {
            pose: pose.map(Into::into),
            size: size.map(Into::into),
            color: color.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "SpherePrimitive(pose={:?}, size={:?}, color={:?})",
            self.0.pose, self.0.size, self.0.color,
        )
    }
    /// Returns the SpherePrimitive schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::SpherePrimitive::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the SpherePrimitive as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<SpherePrimitive> for foxglove::schemas::SpherePrimitive {
    fn from(value: SpherePrimitive) -> Self {
        value.0
    }
}

/// A text label on a 2D image
///
/// :param timestamp: Timestamp of annotation
/// :param position: Bottom-left origin of the text label in 2D image coordinates (pixels).
///     The coordinate uses the top-left corner of the top-left pixel of the image as the origin.
/// :param text: Text to display
/// :param font_size: Font size in pixels
/// :param text_color: Text color
/// :param background_color: Background fill color
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/text-annotation
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct TextAnnotation(pub(crate) foxglove::schemas::TextAnnotation);
#[pymethods]
impl TextAnnotation {
    #[new]
    #[pyo3(signature = (*, timestamp=None, position=None, text="", font_size=0.0, text_color=None, background_color=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        position: Option<Point2>,
        text: &str,
        font_size: f64,
        text_color: Option<Color>,
        background_color: Option<Color>,
    ) -> Self {
        Self(foxglove::schemas::TextAnnotation {
            timestamp: timestamp.map(Into::into),
            position: position.map(Into::into),
            text: text.to_string(),
            font_size,
            text_color: text_color.map(Into::into),
            background_color: background_color.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "TextAnnotation(timestamp={:?}, position={:?}, text={:?}, font_size={:?}, text_color={:?}, background_color={:?})",
            self.0.timestamp,
            self.0.position,
            self.0.text,
            self.0.font_size,
            self.0.text_color,
            self.0.background_color,
        )
    }
    /// Returns the TextAnnotation schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::TextAnnotation::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the TextAnnotation as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<TextAnnotation> for foxglove::schemas::TextAnnotation {
    fn from(value: TextAnnotation) -> Self {
        value.0
    }
}

/// A primitive representing a text label
///
/// :param pose: Position of the center of the text box and orientation of the text. Identity orientation means the text is oriented in the xy-plane and flows from -x to +x.
/// :param billboard: Whether the text should respect `pose.orientation` (false) or always face the camera (true)
/// :param font_size: Font size (height of one line of text)
/// :param scale_invariant: Indicates whether `font_size` is a fixed size in screen pixels (true), or specified in world coordinates and scales with distance from the camera (false)
/// :param color: Color of the text
/// :param text: Text
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/text-primitive
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct TextPrimitive(pub(crate) foxglove::schemas::TextPrimitive);
#[pymethods]
impl TextPrimitive {
    #[new]
    #[pyo3(signature = (*, pose=None, billboard=false, font_size=0.0, scale_invariant=false, color=None, text="") )]
    fn new(
        pose: Option<Pose>,
        billboard: bool,
        font_size: f64,
        scale_invariant: bool,
        color: Option<Color>,
        text: &str,
    ) -> Self {
        Self(foxglove::schemas::TextPrimitive {
            pose: pose.map(Into::into),
            billboard,
            font_size,
            scale_invariant,
            color: color.map(Into::into),
            text: text.to_string(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "TextPrimitive(pose={:?}, billboard={:?}, font_size={:?}, scale_invariant={:?}, color={:?}, text={:?})",
            self.0.pose,
            self.0.billboard,
            self.0.font_size,
            self.0.scale_invariant,
            self.0.color,
            self.0.text,
        )
    }
    /// Returns the TextPrimitive schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::TextPrimitive::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the TextPrimitive as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<TextPrimitive> for foxglove::schemas::TextPrimitive {
    fn from(value: TextPrimitive) -> Self {
        value.0
    }
}

/// A primitive representing a set of triangles or a surface tiled by triangles
///
/// :param pose: Origin of triangles relative to reference frame
/// :param points: Vertices to use for triangles, interpreted as a list of triples (0-1-2, 3-4-5, ...)
/// :param color: Solid color to use for the whole shape. Ignored if `colors` is non-empty.
/// :param colors: Per-vertex colors (if specified, must have the same length as `points`).
/// :param indices: Indices into the `points` and `colors` attribute arrays, which can be used to avoid duplicating attribute data.
///     
///     If omitted or empty, indexing will not be used. This default behavior is equivalent to specifying [0, 1, ..., N-1] for the indices (where N is the number of `points` provided).
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/triangle-list-primitive
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct TriangleListPrimitive(pub(crate) foxglove::schemas::TriangleListPrimitive);
#[pymethods]
impl TriangleListPrimitive {
    #[new]
    #[pyo3(signature = (*, pose=None, points=None, color=None, colors=None, indices=None) )]
    fn new(
        pose: Option<Pose>,
        points: Option<Vec<Point3>>,
        color: Option<Color>,
        colors: Option<Vec<Color>>,
        indices: Option<Vec<u32>>,
    ) -> Self {
        Self(foxglove::schemas::TriangleListPrimitive {
            pose: pose.map(Into::into),
            points: points
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            color: color.map(Into::into),
            colors: colors
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            indices: indices.unwrap_or_default(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "TriangleListPrimitive(pose={:?}, points={:?}, color={:?}, colors={:?}, indices={:?})",
            self.0.pose, self.0.points, self.0.color, self.0.colors, self.0.indices,
        )
    }
    /// Returns the TriangleListPrimitive schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::TriangleListPrimitive::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the TriangleListPrimitive as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<TriangleListPrimitive> for foxglove::schemas::TriangleListPrimitive {
    fn from(value: TriangleListPrimitive) -> Self {
        value.0
    }
}

/// A vector in 2D space that represents a direction only
///
/// :param x: x coordinate length
/// :param y: y coordinate length
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/vector2
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct Vector2(pub(crate) foxglove::schemas::Vector2);
#[pymethods]
impl Vector2 {
    #[new]
    #[pyo3(signature = (*, x=0.0, y=0.0) )]
    fn new(x: f64, y: f64) -> Self {
        Self(foxglove::schemas::Vector2 { x, y })
    }
    fn __repr__(&self) -> String {
        format!("Vector2(x={:?}, y={:?})", self.0.x, self.0.y,)
    }
    /// Returns the Vector2 schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::Vector2::get_schema().unwrap().into()
    }
    /// Encodes the Vector2 as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<Vector2> for foxglove::schemas::Vector2 {
    fn from(value: Vector2) -> Self {
        value.0
    }
}

/// A vector in 3D space that represents a direction only
///
/// :param x: x coordinate length
/// :param y: y coordinate length
/// :param z: z coordinate length
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/vector3
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct Vector3(pub(crate) foxglove::schemas::Vector3);
#[pymethods]
impl Vector3 {
    #[new]
    #[pyo3(signature = (*, x=0.0, y=0.0, z=0.0) )]
    fn new(x: f64, y: f64, z: f64) -> Self {
        Self(foxglove::schemas::Vector3 { x, y, z })
    }
    fn __repr__(&self) -> String {
        format!(
            "Vector3(x={:?}, y={:?}, z={:?})",
            self.0.x, self.0.y, self.0.z,
        )
    }
    /// Returns the Vector3 schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::Vector3::get_schema().unwrap().into()
    }
    /// Encodes the Vector3 as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<Vector3> for foxglove::schemas::Vector3 {
    fn from(value: Vector3) -> Self {
        value.0
    }
}

pub fn register_submodule(parent_module: &Bound<'_, PyModule>) -> PyResult<()> {
    let module = PyModule::new(parent_module.py(), "schemas")?;

    module.add_class::<LinePrimitiveLineType>()?;
    module.add_class::<LogLevel>()?;
    module.add_class::<SceneEntityDeletionType>()?;
    module.add_class::<PackedElementFieldNumericType>()?;
    module.add_class::<PointsAnnotationType>()?;
    module.add_class::<LocationFixPositionCovarianceType>()?;
    module.add_class::<ArrowPrimitive>()?;
    module.add_class::<CameraCalibration>()?;
    module.add_class::<CircleAnnotation>()?;
    module.add_class::<Color>()?;
    module.add_class::<CompressedImage>()?;
    module.add_class::<CompressedVideo>()?;
    module.add_class::<CylinderPrimitive>()?;
    module.add_class::<CubePrimitive>()?;
    module.add_class::<Duration>()?;
    module.add_class::<FrameTransform>()?;
    module.add_class::<FrameTransforms>()?;
    module.add_class::<GeoJson>()?;
    module.add_class::<Grid>()?;
    module.add_class::<VoxelGrid>()?;
    module.add_class::<ImageAnnotations>()?;
    module.add_class::<KeyValuePair>()?;
    module.add_class::<LaserScan>()?;
    module.add_class::<LinePrimitive>()?;
    module.add_class::<LocationFix>()?;
    module.add_class::<LocationFixes>()?;
    module.add_class::<Log>()?;
    module.add_class::<SceneEntityDeletion>()?;
    module.add_class::<SceneEntity>()?;
    module.add_class::<SceneUpdate>()?;
    module.add_class::<ModelPrimitive>()?;
    module.add_class::<PackedElementField>()?;
    module.add_class::<Point2>()?;
    module.add_class::<Point3>()?;
    module.add_class::<PointCloud>()?;
    module.add_class::<PointsAnnotation>()?;
    module.add_class::<Pose>()?;
    module.add_class::<PoseInFrame>()?;
    module.add_class::<PosesInFrame>()?;
    module.add_class::<Quaternion>()?;
    module.add_class::<RawAudio>()?;
    module.add_class::<RawImage>()?;
    module.add_class::<SpherePrimitive>()?;
    module.add_class::<TextAnnotation>()?;
    module.add_class::<TextPrimitive>()?;
    module.add_class::<Timestamp>()?;
    module.add_class::<TriangleListPrimitive>()?;
    module.add_class::<Vector2>()?;
    module.add_class::<Vector3>()?;

    // Define as a package
    // https://github.com/PyO3/pyo3/issues/759
    let py = parent_module.py();
    py.import("sys")?
        .getattr("modules")?
        .set_item("foxglove._foxglove_py.schemas", &module)?;

    parent_module.add_submodule(&module)
}
