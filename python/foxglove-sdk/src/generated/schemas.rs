//! Definitions for well-known Foxglove schemas
//! Generated by https://github.com/foxglove/foxglove-sdk
#![allow(clippy::too_many_arguments)]
#![allow(clippy::enum_variant_names)]
#![allow(non_snake_case)]
use crate::schemas_wkt::{Duration, Timestamp};
use crate::PySchema;
use bytes::Bytes;
use foxglove::Encode;
use pyo3::prelude::*;
use pyo3::types::PyBytes;

/// An enumeration indicating how input points should be interpreted to create lines
#[pyclass(eq, eq_int, module = "foxglove.schemas")]
#[derive(PartialEq, Clone)]
pub(crate) enum LinePrimitiveLineType {
    LineStrip = 0,
    LineLoop = 1,
    LineList = 2,
}

/// Log level
#[pyclass(eq, eq_int, module = "foxglove.schemas")]
#[derive(PartialEq, Clone)]
pub(crate) enum LogLevel {
    Unknown = 0,
    Debug = 1,
    Info = 2,
    Warning = 3,
    Error = 4,
    Fatal = 5,
}

/// An enumeration indicating which entities should match a SceneEntityDeletion command
#[pyclass(eq, eq_int, module = "foxglove.schemas")]
#[derive(PartialEq, Clone)]
pub(crate) enum SceneEntityDeletionType {
    MatchingId = 0,
    All = 1,
}

/// Numeric type
#[pyclass(eq, eq_int, module = "foxglove.schemas")]
#[derive(PartialEq, Clone)]
pub(crate) enum PackedElementFieldNumericType {
    Unknown = 0,
    Uint8 = 1,
    Int8 = 2,
    Uint16 = 3,
    Int16 = 4,
    Uint32 = 5,
    Int32 = 6,
    Float32 = 7,
    Float64 = 8,
}

/// Type of points annotation
#[pyclass(eq, eq_int, module = "foxglove.schemas")]
#[derive(PartialEq, Clone)]
pub(crate) enum PointsAnnotationType {
    Unknown = 0,
    Points = 1,
    LineLoop = 2,
    LineStrip = 3,
    LineList = 4,
}

/// Type of position covariance
#[pyclass(eq, eq_int, module = "foxglove.schemas")]
#[derive(PartialEq, Clone)]
pub(crate) enum LocationFixPositionCovarianceType {
    Unknown = 0,
    Approximated = 1,
    DiagonalKnown = 2,
    Known = 3,
}

/// A primitive representing an arrow
///
/// :param pose: Position of the arrow's tail and orientation of the arrow. Identity orientation means the arrow points in the +x direction.
/// :param shaft_length: Length of the arrow shaft
/// :param shaft_diameter: Diameter of the arrow shaft
/// :param head_length: Length of the arrow head
/// :param head_diameter: Diameter of the arrow head
/// :param color: Color of the arrow
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/arrow-primitive
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct ArrowPrimitive(pub(crate) foxglove::schemas::ArrowPrimitive);
#[pymethods]
impl ArrowPrimitive {
    #[new]
    #[pyo3(signature = (*, pose=None, shaft_length=0.0, shaft_diameter=0.0, head_length=0.0, head_diameter=0.0, color=None) )]
    fn new(
        pose: Option<Pose>,
        shaft_length: f64,
        shaft_diameter: f64,
        head_length: f64,
        head_diameter: f64,
        color: Option<Color>,
    ) -> Self {
        Self(foxglove::schemas::ArrowPrimitive {
            pose: pose.map(Into::into),
            shaft_length,
            shaft_diameter,
            head_length,
            head_diameter,
            color: color.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "ArrowPrimitive(pose={:?}, shaft_length={:?}, shaft_diameter={:?}, head_length={:?}, head_diameter={:?}, color={:?})",
            self.0.pose,
            self.0.shaft_length,
            self.0.shaft_diameter,
            self.0.head_length,
            self.0.head_diameter,
            self.0.color,
        )
    }
    /// Returns the ArrowPrimitive schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::ArrowPrimitive::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the ArrowPrimitive as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<ArrowPrimitive> for foxglove::schemas::ArrowPrimitive {
    fn from(value: ArrowPrimitive) -> Self {
        value.0
    }
}

/// Camera calibration parameters
///
/// :param timestamp: Timestamp of calibration data
/// :param frame_id: Frame of reference for the camera. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
/// :param width: Image width
/// :param height: Image height
/// :param distortion_model: Name of distortion model
///     
///     Supported parameters: `plumb_bob` (k1, k2, p1, p2, k3), `rational_polynomial` (k1, k2, p1, p2, k3, k4, k5, k6), and `kannala_brandt` (k1, k2, k3, k4). `plumb_bob` and `rational_polynomial` models are based on the pinhole model `OpenCV's <https://docs.opencv.org/4.11.0/d9/d0c/group__calib3d.html>`__ `pinhole camera model <https://en.wikipedia.org/wiki/Distortion_%28optics%29#Software_correction>`__. The `kannala_brandt` model matches the `OpenvCV fisheye <https://docs.opencv.org/4.11.0/db/d58/group__calib3d__fisheye.html>`__ model.
/// :param D: Distortion parameters
/// :param K: Intrinsic camera matrix (3x3 row-major matrix)
///     
///     A 3x3 row-major matrix for the raw (distorted) image.
///     
///     Projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal lengths (fx, fy) and principal point (cx, cy).
///     
///     ::
///
///             [fx  0 cx]
///         K = [ 0 fy cy]
///             [ 0  0  1]
///     
/// :param R: Rectification matrix (stereo cameras only, 3x3 row-major matrix)
///     
///     A rotation matrix aligning the camera coordinate system to the ideal stereo image plane so that epipolar lines in both stereo images are parallel.
/// :param P: Projection/camera matrix (3x4 row-major matrix)
///     
///     ::
///
///             [fx'  0  cx' Tx]
///         P = [ 0  fy' cy' Ty]
///             [ 0   0   1   0]
///     
///     By convention, this matrix specifies the intrinsic (camera) matrix of the processed (rectified) image. That is, the left 3x3 portion is the normal camera intrinsic matrix for the rectified image.
///     
///     It projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal lengths (fx', fy') and principal point (cx', cy') - these may differ from the values in K.
///     
///     For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will also have R = the identity and P[1:3,1:3] = K.
///     
///     For a stereo pair, the fourth column [Tx Ty 0]' is related to the position of the optical center of the second camera in the first camera's frame. We assume Tz = 0 so both cameras are in the same stereo image plane. The first camera always has Tx = Ty = 0. For the right (second) camera of a horizontal stereo pair, Ty = 0 and Tx = -fx' * B, where B is the baseline between the cameras.
///     
///     Given a 3D point [X Y Z]', the projection (x, y) of the point onto the rectified image is given by:
///     
///     ::
///
///         [u v w]' = P * [X Y Z 1]'
///                x = u / w
///                y = v / w
///     
///     This holds for both images of a stereo pair.
///     
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/camera-calibration
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct CameraCalibration(pub(crate) foxglove::schemas::CameraCalibration);
#[pymethods]
impl CameraCalibration {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", width=0, height=0, distortion_model="", D=None, K=None, R=None, P=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        width: u32,
        height: u32,
        distortion_model: &str,
        D: Option<Vec<f64>>,
        K: Option<Vec<f64>>,
        R: Option<Vec<f64>>,
        P: Option<Vec<f64>>,
    ) -> Self {
        Self(foxglove::schemas::CameraCalibration {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            width,
            height,
            distortion_model: distortion_model.to_string(),
            d: D.unwrap_or_default(),
            k: K.unwrap_or_default(),
            r: R.unwrap_or_default(),
            p: P.unwrap_or_default(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "CameraCalibration(timestamp={:?}, frame_id={:?}, width={:?}, height={:?}, distortion_model={:?}, D={:?}, K={:?}, R={:?}, P={:?})",
            self.0.timestamp,
            self.0.frame_id,
            self.0.width,
            self.0.height,
            self.0.distortion_model,
            self.0.d,
            self.0.k,
            self.0.r,
            self.0.p,
        )
    }
    /// Returns the CameraCalibration schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::CameraCalibration::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the CameraCalibration as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<CameraCalibration> for foxglove::schemas::CameraCalibration {
    fn from(value: CameraCalibration) -> Self {
        value.0
    }
}

/// A circle annotation on a 2D image
///
/// :param timestamp: Timestamp of circle
/// :param position: Center of the circle in 2D image coordinates (pixels).
///     The coordinate uses the top-left corner of the top-left pixel of the image as the origin.
/// :param diameter: Circle diameter in pixels
/// :param thickness: Line thickness in pixels
/// :param fill_color: Fill color
/// :param outline_color: Outline color
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/circle-annotation
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct CircleAnnotation(pub(crate) foxglove::schemas::CircleAnnotation);
#[pymethods]
impl CircleAnnotation {
    #[new]
    #[pyo3(signature = (*, timestamp=None, position=None, diameter=0.0, thickness=0.0, fill_color=None, outline_color=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        position: Option<Point2>,
        diameter: f64,
        thickness: f64,
        fill_color: Option<Color>,
        outline_color: Option<Color>,
    ) -> Self {
        Self(foxglove::schemas::CircleAnnotation {
            timestamp: timestamp.map(Into::into),
            position: position.map(Into::into),
            diameter,
            thickness,
            fill_color: fill_color.map(Into::into),
            outline_color: outline_color.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "CircleAnnotation(timestamp={:?}, position={:?}, diameter={:?}, thickness={:?}, fill_color={:?}, outline_color={:?})",
            self.0.timestamp,
            self.0.position,
            self.0.diameter,
            self.0.thickness,
            self.0.fill_color,
            self.0.outline_color,
        )
    }
    /// Returns the CircleAnnotation schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::CircleAnnotation::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the CircleAnnotation as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<CircleAnnotation> for foxglove::schemas::CircleAnnotation {
    fn from(value: CircleAnnotation) -> Self {
        value.0
    }
}

/// A color in RGBA format
///
/// :param r: Red value between 0 and 1
/// :param g: Green value between 0 and 1
/// :param b: Blue value between 0 and 1
/// :param a: Alpha value between 0 and 1
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/color
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct Color(pub(crate) foxglove::schemas::Color);
#[pymethods]
impl Color {
    #[new]
    #[pyo3(signature = (*, r=0.0, g=0.0, b=0.0, a=0.0) )]
    fn new(r: f64, g: f64, b: f64, a: f64) -> Self {
        Self(foxglove::schemas::Color { r, g, b, a })
    }
    fn __repr__(&self) -> String {
        format!(
            "Color(r={:?}, g={:?}, b={:?}, a={:?})",
            self.0.r, self.0.g, self.0.b, self.0.a,
        )
    }
    /// Returns the Color schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::Color::get_schema().unwrap().into()
    }
    /// Encodes the Color as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<Color> for foxglove::schemas::Color {
    fn from(value: Color) -> Self {
        value.0
    }
}

/// A compressed image
///
/// :param timestamp: Timestamp of image
/// :param frame_id: Frame of reference for the image. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
/// :param data: Compressed image data
/// :param format: Image format
///     
///     Supported values: `jpeg`, `png`, `webp`, `avif`
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/compressed-image
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct CompressedImage(pub(crate) foxglove::schemas::CompressedImage);
#[pymethods]
impl CompressedImage {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", data=None, format="") )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        data: Option<Bound<'_, PyBytes>>,
        format: &str,
    ) -> Self {
        Self(foxglove::schemas::CompressedImage {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            data: data
                .map(|x| Bytes::copy_from_slice(x.as_bytes()))
                .unwrap_or_default(),
            format: format.to_string(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "CompressedImage(timestamp={:?}, frame_id={:?}, data={:?}, format={:?})",
            self.0.timestamp, self.0.frame_id, self.0.data, self.0.format,
        )
    }
    /// Returns the CompressedImage schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::CompressedImage::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the CompressedImage as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<CompressedImage> for foxglove::schemas::CompressedImage {
    fn from(value: CompressedImage) -> Self {
        value.0
    }
}

/// A single frame of a compressed video bitstream
///
/// :param timestamp: Timestamp of video frame
/// :param frame_id: Frame of reference for the video.
///     
///     The origin of the frame is the optical center of the camera. +x points to the right in the video, +y points down, and +z points into the plane of the video.
/// :param data: Compressed video frame data.
///     
///     For packet-based video codecs this data must begin and end on packet boundaries (no partial packets), and must contain enough video packets to decode exactly one image (either a keyframe or delta frame). Note: Foxglove does not support video streams that include B frames because they require lookahead.
///     
///     Specifically, the requirements for different `format` values are:
///     
///     - `h264`
///       - Use Annex B formatted data
///       - Each CompressedVideo message should contain enough NAL units to decode exactly one video frame
///       - Each message containing a key frame (IDR) must also include a SPS NAL unit
///     
///     - `h265` (HEVC)
///       - Use Annex B formatted data
///       - Each CompressedVideo message should contain enough NAL units to decode exactly one video frame
///       - Each message containing a key frame (IRAP) must also include relevant VPS/SPS/PPS NAL units
///     
///     - `vp9`
///       - Each CompressedVideo message should contain exactly one video frame
///     
///     - `av1`
///       - Use the "Low overhead bitstream format" (section 5.2)
///       - Each CompressedVideo message should contain enough OBUs to decode exactly one video frame
///       - Each message containing a key frame must also include a Sequence Header OBU
/// :param format: Video format.
///     
///     Supported values: `h264`, `h265`, `vp9`, `av1`.
///     
///     Note: compressed video support is subject to hardware limitations and patent licensing, so not all encodings may be supported on all platforms. See more about `H.265 support <https://caniuse.com/hevc>`__, `VP9 support <https://caniuse.com/webm>`__, and `AV1 support <https://caniuse.com/av1>`__.
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/compressed-video
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct CompressedVideo(pub(crate) foxglove::schemas::CompressedVideo);
#[pymethods]
impl CompressedVideo {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", data=None, format="") )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        data: Option<Bound<'_, PyBytes>>,
        format: &str,
    ) -> Self {
        Self(foxglove::schemas::CompressedVideo {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            data: data
                .map(|x| Bytes::copy_from_slice(x.as_bytes()))
                .unwrap_or_default(),
            format: format.to_string(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "CompressedVideo(timestamp={:?}, frame_id={:?}, data={:?}, format={:?})",
            self.0.timestamp, self.0.frame_id, self.0.data, self.0.format,
        )
    }
    /// Returns the CompressedVideo schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::CompressedVideo::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the CompressedVideo as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<CompressedVideo> for foxglove::schemas::CompressedVideo {
    fn from(value: CompressedVideo) -> Self {
        value.0
    }
}

/// A primitive representing a cylinder, elliptic cylinder, or truncated cone
///
/// :param pose: Position of the center of the cylinder and orientation of the cylinder. The flat face(s) are perpendicular to the z-axis.
/// :param size: Size of the cylinder's bounding box
/// :param bottom_scale: 0-1, ratio of the diameter of the cylinder's bottom face (min z) to the bottom of the bounding box
/// :param top_scale: 0-1, ratio of the diameter of the cylinder's top face (max z) to the top of the bounding box
/// :param color: Color of the cylinder
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/cylinder-primitive
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct CylinderPrimitive(pub(crate) foxglove::schemas::CylinderPrimitive);
#[pymethods]
impl CylinderPrimitive {
    #[new]
    #[pyo3(signature = (*, pose=None, size=None, bottom_scale=0.0, top_scale=0.0, color=None) )]
    fn new(
        pose: Option<Pose>,
        size: Option<Vector3>,
        bottom_scale: f64,
        top_scale: f64,
        color: Option<Color>,
    ) -> Self {
        Self(foxglove::schemas::CylinderPrimitive {
            pose: pose.map(Into::into),
            size: size.map(Into::into),
            bottom_scale,
            top_scale,
            color: color.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "CylinderPrimitive(pose={:?}, size={:?}, bottom_scale={:?}, top_scale={:?}, color={:?})",
            self.0.pose,
            self.0.size,
            self.0.bottom_scale,
            self.0.top_scale,
            self.0.color,
        )
    }
    /// Returns the CylinderPrimitive schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::CylinderPrimitive::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the CylinderPrimitive as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<CylinderPrimitive> for foxglove::schemas::CylinderPrimitive {
    fn from(value: CylinderPrimitive) -> Self {
        value.0
    }
}

/// A primitive representing a cube or rectangular prism
///
/// :param pose: Position of the center of the cube and orientation of the cube
/// :param size: Size of the cube along each axis
/// :param color: Color of the cube
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/cube-primitive
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct CubePrimitive(pub(crate) foxglove::schemas::CubePrimitive);
#[pymethods]
impl CubePrimitive {
    #[new]
    #[pyo3(signature = (*, pose=None, size=None, color=None) )]
    fn new(pose: Option<Pose>, size: Option<Vector3>, color: Option<Color>) -> Self {
        Self(foxglove::schemas::CubePrimitive {
            pose: pose.map(Into::into),
            size: size.map(Into::into),
            color: color.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "CubePrimitive(pose={:?}, size={:?}, color={:?})",
            self.0.pose, self.0.size, self.0.color,
        )
    }
    /// Returns the CubePrimitive schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::CubePrimitive::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the CubePrimitive as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<CubePrimitive> for foxglove::schemas::CubePrimitive {
    fn from(value: CubePrimitive) -> Self {
        value.0
    }
}

/// A transform between two reference frames in 3D space
///
/// :param timestamp: Timestamp of transform
/// :param parent_frame_id: Name of the parent frame
/// :param child_frame_id: Name of the child frame
/// :param translation: Translation component of the transform
/// :param rotation: Rotation component of the transform
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/frame-transform
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct FrameTransform(pub(crate) foxglove::schemas::FrameTransform);
#[pymethods]
impl FrameTransform {
    #[new]
    #[pyo3(signature = (*, timestamp=None, parent_frame_id="", child_frame_id="", translation=None, rotation=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        parent_frame_id: &str,
        child_frame_id: &str,
        translation: Option<Vector3>,
        rotation: Option<Quaternion>,
    ) -> Self {
        Self(foxglove::schemas::FrameTransform {
            timestamp: timestamp.map(Into::into),
            parent_frame_id: parent_frame_id.to_string(),
            child_frame_id: child_frame_id.to_string(),
            translation: translation.map(Into::into),
            rotation: rotation.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "FrameTransform(timestamp={:?}, parent_frame_id={:?}, child_frame_id={:?}, translation={:?}, rotation={:?})",
            self.0.timestamp,
            self.0.parent_frame_id,
            self.0.child_frame_id,
            self.0.translation,
            self.0.rotation,
        )
    }
    /// Returns the FrameTransform schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::FrameTransform::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the FrameTransform as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<FrameTransform> for foxglove::schemas::FrameTransform {
    fn from(value: FrameTransform) -> Self {
        value.0
    }
}

/// An array of FrameTransform messages
///
/// :param transforms: Array of transforms
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/frame-transforms
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct FrameTransforms(pub(crate) foxglove::schemas::FrameTransforms);
#[pymethods]
impl FrameTransforms {
    #[new]
    #[pyo3(signature = (*, transforms=None) )]
    fn new(transforms: Option<Vec<FrameTransform>>) -> Self {
        Self(foxglove::schemas::FrameTransforms {
            transforms: transforms
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
        })
    }
    fn __repr__(&self) -> String {
        format!("FrameTransforms(transforms={:?})", self.0.transforms,)
    }
    /// Returns the FrameTransforms schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::FrameTransforms::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the FrameTransforms as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<FrameTransforms> for foxglove::schemas::FrameTransforms {
    fn from(value: FrameTransforms) -> Self {
        value.0
    }
}

/// GeoJSON data for annotating maps
///
/// :param geojson: GeoJSON data encoded as a UTF-8 string
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/geo-json
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct GeoJson(pub(crate) foxglove::schemas::GeoJson);
#[pymethods]
impl GeoJson {
    #[new]
    #[pyo3(signature = (*, geojson="") )]
    fn new(geojson: &str) -> Self {
        Self(foxglove::schemas::GeoJson {
            geojson: geojson.to_string(),
        })
    }
    fn __repr__(&self) -> String {
        format!("GeoJson(geojson={:?})", self.0.geojson,)
    }
    /// Returns the GeoJson schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::GeoJson::get_schema().unwrap().into()
    }
    /// Encodes the GeoJson as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<GeoJson> for foxglove::schemas::GeoJson {
    fn from(value: GeoJson) -> Self {
        value.0
    }
}

/// A 2D grid of data
///
/// :param timestamp: Timestamp of grid
/// :param frame_id: Frame of reference
/// :param pose: Origin of grid's corner relative to frame of reference; grid is positioned in the x-y plane relative to this origin
/// :param column_count: Number of grid columns
/// :param cell_size: Size of single grid cell along x and y axes, relative to `pose`
/// :param row_stride: Number of bytes between rows in `data`
/// :param cell_stride: Number of bytes between cells within a row in `data`
/// :param fields: Fields in `data`. `red`, `green`, `blue`, and `alpha` are optional for customizing the grid's color.
/// :param data: Grid cell data, interpreted using `fields`, in row-major (y-major) order.
///      For the data element starting at byte offset i, the coordinates of its corner closest to the origin will be:
///      y = (i / cell_stride) % row_stride * cell_size.y
///      x = i % cell_stride * cell_size.x
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/grid
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct Grid(pub(crate) foxglove::schemas::Grid);
#[pymethods]
impl Grid {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", pose=None, column_count=0, cell_size=None, row_stride=0, cell_stride=0, fields=None, data=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        pose: Option<Pose>,
        column_count: u32,
        cell_size: Option<Vector2>,
        row_stride: u32,
        cell_stride: u32,
        fields: Option<Vec<PackedElementField>>,
        data: Option<Bound<'_, PyBytes>>,
    ) -> Self {
        Self(foxglove::schemas::Grid {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            pose: pose.map(Into::into),
            column_count,
            cell_size: cell_size.map(Into::into),
            row_stride,
            cell_stride,
            fields: fields
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            data: data
                .map(|x| Bytes::copy_from_slice(x.as_bytes()))
                .unwrap_or_default(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "Grid(timestamp={:?}, frame_id={:?}, pose={:?}, column_count={:?}, cell_size={:?}, row_stride={:?}, cell_stride={:?}, fields={:?}, data={:?})",
            self.0.timestamp,
            self.0.frame_id,
            self.0.pose,
            self.0.column_count,
            self.0.cell_size,
            self.0.row_stride,
            self.0.cell_stride,
            self.0.fields,
            self.0.data,
        )
    }
    /// Returns the Grid schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::Grid::get_schema().unwrap().into()
    }
    /// Encodes the Grid as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<Grid> for foxglove::schemas::Grid {
    fn from(value: Grid) -> Self {
        value.0
    }
}

/// A 3D grid of data
///
/// :param timestamp: Timestamp of grid
/// :param frame_id: Frame of reference
/// :param pose: Origin of grid's corner relative to frame of reference
/// :param row_count: Number of grid rows
/// :param column_count: Number of grid columns
/// :param cell_size: Size of single grid cell along x, y, and z axes, relative to `pose`
/// :param slice_stride: Number of bytes between depth slices in `data`
/// :param row_stride: Number of bytes between rows in `data`
/// :param cell_stride: Number of bytes between cells within a row in `data`
/// :param fields: Fields in `data`. `red`, `green`, `blue`, and `alpha` are optional for customizing the grid's color.
/// :param data: Grid cell data, interpreted using `fields`, in depth-major, row-major (Z-Y-X) order.
///      For the data element starting at byte offset i, the coordinates of its corner closest to the origin will be:
///      z = i / slice_stride * cell_size.z
///      y = (i % slice_stride) / row_stride * cell_size.y
///      x = (i % row_stride) / cell_stride * cell_size.x
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/voxel-grid
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct VoxelGrid(pub(crate) foxglove::schemas::VoxelGrid);
#[pymethods]
impl VoxelGrid {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", pose=None, row_count=0, column_count=0, cell_size=None, slice_stride=0, row_stride=0, cell_stride=0, fields=None, data=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        pose: Option<Pose>,
        row_count: u32,
        column_count: u32,
        cell_size: Option<Vector3>,
        slice_stride: u32,
        row_stride: u32,
        cell_stride: u32,
        fields: Option<Vec<PackedElementField>>,
        data: Option<Bound<'_, PyBytes>>,
    ) -> Self {
        Self(foxglove::schemas::VoxelGrid {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            pose: pose.map(Into::into),
            row_count,
            column_count,
            cell_size: cell_size.map(Into::into),
            slice_stride,
            row_stride,
            cell_stride,
            fields: fields
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            data: data
                .map(|x| Bytes::copy_from_slice(x.as_bytes()))
                .unwrap_or_default(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "VoxelGrid(timestamp={:?}, frame_id={:?}, pose={:?}, row_count={:?}, column_count={:?}, cell_size={:?}, slice_stride={:?}, row_stride={:?}, cell_stride={:?}, fields={:?}, data={:?})",
            self.0.timestamp,
            self.0.frame_id,
            self.0.pose,
            self.0.row_count,
            self.0.column_count,
            self.0.cell_size,
            self.0.slice_stride,
            self.0.row_stride,
            self.0.cell_stride,
            self.0.fields,
            self.0.data,
        )
    }
    /// Returns the VoxelGrid schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::VoxelGrid::get_schema().unwrap().into()
    }
    /// Encodes the VoxelGrid as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<VoxelGrid> for foxglove::schemas::VoxelGrid {
    fn from(value: VoxelGrid) -> Self {
        value.0
    }
}

/// Array of annotations for a 2D image
///
/// :param circles: Circle annotations
/// :param points: Points annotations
/// :param texts: Text annotations
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/image-annotations
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct ImageAnnotations(pub(crate) foxglove::schemas::ImageAnnotations);
#[pymethods]
impl ImageAnnotations {
    #[new]
    #[pyo3(signature = (*, circles=None, points=None, texts=None) )]
    fn new(
        circles: Option<Vec<CircleAnnotation>>,
        points: Option<Vec<PointsAnnotation>>,
        texts: Option<Vec<TextAnnotation>>,
    ) -> Self {
        Self(foxglove::schemas::ImageAnnotations {
            circles: circles
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            points: points
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            texts: texts
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "ImageAnnotations(circles={:?}, points={:?}, texts={:?})",
            self.0.circles, self.0.points, self.0.texts,
        )
    }
    /// Returns the ImageAnnotations schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::ImageAnnotations::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the ImageAnnotations as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<ImageAnnotations> for foxglove::schemas::ImageAnnotations {
    fn from(value: ImageAnnotations) -> Self {
        value.0
    }
}

/// A key with its associated value
///
/// :param key: Key
/// :param value: Value
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/key-value-pair
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct KeyValuePair(pub(crate) foxglove::schemas::KeyValuePair);
#[pymethods]
impl KeyValuePair {
    #[new]
    #[pyo3(signature = (*, key="", value="") )]
    fn new(key: &str, value: &str) -> Self {
        Self(foxglove::schemas::KeyValuePair {
            key: key.to_string(),
            value: value.to_string(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "KeyValuePair(key={:?}, value={:?})",
            self.0.key, self.0.value,
        )
    }
    /// Returns the KeyValuePair schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::KeyValuePair::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the KeyValuePair as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<KeyValuePair> for foxglove::schemas::KeyValuePair {
    fn from(value: KeyValuePair) -> Self {
        value.0
    }
}

/// A single scan from a planar laser range-finder
///
/// :param timestamp: Timestamp of scan
/// :param frame_id: Frame of reference
/// :param pose: Origin of scan relative to frame of reference; points are positioned in the x-y plane relative to this origin; angles are interpreted as counterclockwise rotations around the z axis with 0 rad being in the +x direction
/// :param start_angle: Bearing of first point, in radians
/// :param end_angle: Bearing of last point, in radians
/// :param ranges: Distance of detections from origin; assumed to be at equally-spaced angles between `start_angle` and `end_angle`
/// :param intensities: Intensity of detections
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/laser-scan
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct LaserScan(pub(crate) foxglove::schemas::LaserScan);
#[pymethods]
impl LaserScan {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", pose=None, start_angle=0.0, end_angle=0.0, ranges=None, intensities=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        pose: Option<Pose>,
        start_angle: f64,
        end_angle: f64,
        ranges: Option<Vec<f64>>,
        intensities: Option<Vec<f64>>,
    ) -> Self {
        Self(foxglove::schemas::LaserScan {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            pose: pose.map(Into::into),
            start_angle,
            end_angle,
            ranges: ranges.unwrap_or_default(),
            intensities: intensities.unwrap_or_default(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "LaserScan(timestamp={:?}, frame_id={:?}, pose={:?}, start_angle={:?}, end_angle={:?}, ranges={:?}, intensities={:?})",
            self.0.timestamp,
            self.0.frame_id,
            self.0.pose,
            self.0.start_angle,
            self.0.end_angle,
            self.0.ranges,
            self.0.intensities,
        )
    }
    /// Returns the LaserScan schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::LaserScan::get_schema().unwrap().into()
    }
    /// Encodes the LaserScan as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<LaserScan> for foxglove::schemas::LaserScan {
    fn from(value: LaserScan) -> Self {
        value.0
    }
}

/// A primitive representing a series of points connected by lines
///
/// :param type: Drawing primitive to use for lines
/// :param pose: Origin of lines relative to reference frame
/// :param thickness: Line thickness
/// :param scale_invariant: Indicates whether `thickness` is a fixed size in screen pixels (true), or specified in world coordinates and scales with distance from the camera (false)
/// :param points: Points along the line
/// :param color: Solid color to use for the whole line. One of `color` or `colors` must be provided.
/// :param colors: Per-point colors (if specified, must have the same length as `points`). One of `color` or `colors` must be provided.
/// :param indices: Indices into the `points` and `colors` attribute arrays, which can be used to avoid duplicating attribute data.
///     
///     If omitted or empty, indexing will not be used. This default behavior is equivalent to specifying [0, 1, ..., N-1] for the indices (where N is the number of `points` provided).
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/line-primitive
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct LinePrimitive(pub(crate) foxglove::schemas::LinePrimitive);
#[pymethods]
impl LinePrimitive {
    #[new]
    #[pyo3(signature = (*, r#type=LinePrimitiveLineType::LineStrip, pose=None, thickness=0.0, scale_invariant=false, points=None, color=None, colors=None, indices=None) )]
    fn new(
        r#type: LinePrimitiveLineType,
        pose: Option<Pose>,
        thickness: f64,
        scale_invariant: bool,
        points: Option<Vec<Point3>>,
        color: Option<Color>,
        colors: Option<Vec<Color>>,
        indices: Option<Vec<u32>>,
    ) -> Self {
        Self(foxglove::schemas::LinePrimitive {
            r#type: r#type as i32,
            pose: pose.map(Into::into),
            thickness,
            scale_invariant,
            points: points
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            color: color.map(Into::into),
            colors: colors
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            indices: indices.unwrap_or_default(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "LinePrimitive(r#type={:?}, pose={:?}, thickness={:?}, scale_invariant={:?}, points={:?}, color={:?}, colors={:?}, indices={:?})",
            self.0.r#type,
            self.0.pose,
            self.0.thickness,
            self.0.scale_invariant,
            self.0.points,
            self.0.color,
            self.0.colors,
            self.0.indices,
        )
    }
    /// Returns the LinePrimitive schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::LinePrimitive::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the LinePrimitive as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<LinePrimitive> for foxglove::schemas::LinePrimitive {
    fn from(value: LinePrimitive) -> Self {
        value.0
    }
}

/// A navigation satellite fix for any Global Navigation Satellite System
///
/// :param timestamp: Timestamp of the message
/// :param frame_id: Frame for the sensor. Latitude and longitude readings are at the origin of the frame.
/// :param latitude: Latitude in degrees
/// :param longitude: Longitude in degrees
/// :param altitude: Altitude in meters
/// :param position_covariance: Position covariance (m^2) defined relative to a tangential plane through the reported position. The components are East, North, and Up (ENU), in row-major order.
/// :param position_covariance_type: If `position_covariance` is available, `position_covariance_type` must be set to indicate the type of covariance.
/// :param color: Color used to visualize the location
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/location-fix
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct LocationFix(pub(crate) foxglove::schemas::LocationFix);
#[pymethods]
impl LocationFix {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", latitude=0.0, longitude=0.0, altitude=0.0, position_covariance=None, position_covariance_type=LocationFixPositionCovarianceType::Unknown, color=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        latitude: f64,
        longitude: f64,
        altitude: f64,
        position_covariance: Option<Vec<f64>>,
        position_covariance_type: LocationFixPositionCovarianceType,
        color: Option<Color>,
    ) -> Self {
        Self(foxglove::schemas::LocationFix {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            latitude,
            longitude,
            altitude,
            position_covariance: position_covariance.unwrap_or_default(),
            position_covariance_type: position_covariance_type as i32,
            color: color.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "LocationFix(timestamp={:?}, frame_id={:?}, latitude={:?}, longitude={:?}, altitude={:?}, position_covariance={:?}, position_covariance_type={:?}, color={:?})",
            self.0.timestamp,
            self.0.frame_id,
            self.0.latitude,
            self.0.longitude,
            self.0.altitude,
            self.0.position_covariance,
            self.0.position_covariance_type,
            self.0.color,
        )
    }
    /// Returns the LocationFix schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::LocationFix::get_schema().unwrap().into()
    }
    /// Encodes the LocationFix as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<LocationFix> for foxglove::schemas::LocationFix {
    fn from(value: LocationFix) -> Self {
        value.0
    }
}

/// A group of LocationFix messages
///
/// :param fixes: An array of location fixes
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/location-fixes
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct LocationFixes(pub(crate) foxglove::schemas::LocationFixes);
#[pymethods]
impl LocationFixes {
    #[new]
    #[pyo3(signature = (*, fixes=None) )]
    fn new(fixes: Option<Vec<LocationFix>>) -> Self {
        Self(foxglove::schemas::LocationFixes {
            fixes: fixes
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
        })
    }
    fn __repr__(&self) -> String {
        format!("LocationFixes(fixes={:?})", self.0.fixes,)
    }
    /// Returns the LocationFixes schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::LocationFixes::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the LocationFixes as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<LocationFixes> for foxglove::schemas::LocationFixes {
    fn from(value: LocationFixes) -> Self {
        value.0
    }
}

/// A log message
///
/// :param timestamp: Timestamp of log message
/// :param level: Log level
/// :param message: Log message
/// :param name: Process or node name
/// :param file: Filename
/// :param line: Line number in the file
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/log
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct Log(pub(crate) foxglove::schemas::Log);
#[pymethods]
impl Log {
    #[new]
    #[pyo3(signature = (*, timestamp=None, level=LogLevel::Unknown, message="", name="", file="", line=0) )]
    fn new(
        timestamp: Option<Timestamp>,
        level: LogLevel,
        message: &str,
        name: &str,
        file: &str,
        line: u32,
    ) -> Self {
        Self(foxglove::schemas::Log {
            timestamp: timestamp.map(Into::into),
            level: level as i32,
            message: message.to_string(),
            name: name.to_string(),
            file: file.to_string(),
            line,
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "Log(timestamp={:?}, level={:?}, message={:?}, name={:?}, file={:?}, line={:?})",
            self.0.timestamp, self.0.level, self.0.message, self.0.name, self.0.file, self.0.line,
        )
    }
    /// Returns the Log schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::Log::get_schema().unwrap().into()
    }
    /// Encodes the Log as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<Log> for foxglove::schemas::Log {
    fn from(value: Log) -> Self {
        value.0
    }
}

/// Command to remove previously published entities
///
/// :param timestamp: Timestamp of the deletion. Only matching entities earlier than this timestamp will be deleted.
/// :param type: Type of deletion action to perform
/// :param id: Identifier which must match if `type` is `MATCHING_ID`.
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/scene-entity-deletion
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct SceneEntityDeletion(pub(crate) foxglove::schemas::SceneEntityDeletion);
#[pymethods]
impl SceneEntityDeletion {
    #[new]
    #[pyo3(signature = (*, timestamp=None, r#type=SceneEntityDeletionType::MatchingId, id="") )]
    fn new(timestamp: Option<Timestamp>, r#type: SceneEntityDeletionType, id: &str) -> Self {
        Self(foxglove::schemas::SceneEntityDeletion {
            timestamp: timestamp.map(Into::into),
            r#type: r#type as i32,
            id: id.to_string(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "SceneEntityDeletion(timestamp={:?}, r#type={:?}, id={:?})",
            self.0.timestamp, self.0.r#type, self.0.id,
        )
    }
    /// Returns the SceneEntityDeletion schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::SceneEntityDeletion::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the SceneEntityDeletion as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<SceneEntityDeletion> for foxglove::schemas::SceneEntityDeletion {
    fn from(value: SceneEntityDeletion) -> Self {
        value.0
    }
}

/// A visual element in a 3D scene. An entity may be composed of multiple primitives which all share the same frame of reference.
///
/// :param timestamp: Timestamp of the entity
/// :param frame_id: Frame of reference
/// :param id: Identifier for the entity. A entity will replace any prior entity on the same topic with the same `id`.
/// :param lifetime: Length of time (relative to `timestamp`) after which the entity should be automatically removed. Zero value indicates the entity should remain visible until it is replaced or deleted.
/// :param frame_locked: Whether the entity should keep its location in the fixed frame (false) or follow the frame specified in `frame_id` as it moves relative to the fixed frame (true)
/// :param metadata: Additional user-provided metadata associated with the entity. Keys must be unique.
/// :param arrows: Arrow primitives
/// :param cubes: Cube primitives
/// :param spheres: Sphere primitives
/// :param cylinders: Cylinder primitives
/// :param lines: Line primitives
/// :param triangles: Triangle list primitives
/// :param texts: Text primitives
/// :param models: Model primitives
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/scene-entity
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct SceneEntity(pub(crate) foxglove::schemas::SceneEntity);
#[pymethods]
impl SceneEntity {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", id="", lifetime=None, frame_locked=false, metadata=None, arrows=None, cubes=None, spheres=None, cylinders=None, lines=None, triangles=None, texts=None, models=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        id: &str,
        lifetime: Option<Duration>,
        frame_locked: bool,
        metadata: Option<Vec<KeyValuePair>>,
        arrows: Option<Vec<ArrowPrimitive>>,
        cubes: Option<Vec<CubePrimitive>>,
        spheres: Option<Vec<SpherePrimitive>>,
        cylinders: Option<Vec<CylinderPrimitive>>,
        lines: Option<Vec<LinePrimitive>>,
        triangles: Option<Vec<TriangleListPrimitive>>,
        texts: Option<Vec<TextPrimitive>>,
        models: Option<Vec<ModelPrimitive>>,
    ) -> Self {
        Self(foxglove::schemas::SceneEntity {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            id: id.to_string(),
            lifetime: lifetime.map(Into::into),
            frame_locked,
            metadata: metadata
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            arrows: arrows
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            cubes: cubes
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            spheres: spheres
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            cylinders: cylinders
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            lines: lines
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            triangles: triangles
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            texts: texts
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            models: models
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "SceneEntity(timestamp={:?}, frame_id={:?}, id={:?}, lifetime={:?}, frame_locked={:?}, metadata={:?}, arrows={:?}, cubes={:?}, spheres={:?}, cylinders={:?}, lines={:?}, triangles={:?}, texts={:?}, models={:?})",
            self.0.timestamp,
            self.0.frame_id,
            self.0.id,
            self.0.lifetime,
            self.0.frame_locked,
            self.0.metadata,
            self.0.arrows,
            self.0.cubes,
            self.0.spheres,
            self.0.cylinders,
            self.0.lines,
            self.0.triangles,
            self.0.texts,
            self.0.models,
        )
    }
    /// Returns the SceneEntity schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::SceneEntity::get_schema().unwrap().into()
    }
    /// Encodes the SceneEntity as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<SceneEntity> for foxglove::schemas::SceneEntity {
    fn from(value: SceneEntity) -> Self {
        value.0
    }
}

/// An update to the entities displayed in a 3D scene
///
/// :param deletions: Scene entities to delete
/// :param entities: Scene entities to add or replace
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/scene-update
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct SceneUpdate(pub(crate) foxglove::schemas::SceneUpdate);
#[pymethods]
impl SceneUpdate {
    #[new]
    #[pyo3(signature = (*, deletions=None, entities=None) )]
    fn new(
        deletions: Option<Vec<SceneEntityDeletion>>,
        entities: Option<Vec<SceneEntity>>,
    ) -> Self {
        Self(foxglove::schemas::SceneUpdate {
            deletions: deletions
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            entities: entities
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "SceneUpdate(deletions={:?}, entities={:?})",
            self.0.deletions, self.0.entities,
        )
    }
    /// Returns the SceneUpdate schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::SceneUpdate::get_schema().unwrap().into()
    }
    /// Encodes the SceneUpdate as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<SceneUpdate> for foxglove::schemas::SceneUpdate {
    fn from(value: SceneUpdate) -> Self {
        value.0
    }
}

/// A primitive representing a 3D model file loaded from an external URL or embedded data
///
/// :param pose: Origin of model relative to reference frame
/// :param scale: Scale factor to apply to the model along each axis
/// :param color: Solid color to use for the whole model if `override_color` is true.
/// :param override_color: Whether to use the color specified in `color` instead of any materials embedded in the original model.
/// :param url: URL pointing to model file. One of `url` or `data` should be provided.
/// :param media_type: [Media type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) of embedded model (e.g. `model/gltf-binary`). Required if `data` is provided instead of `url`. Overrides the inferred media type if `url` is provided.
/// :param data: Embedded model. One of `url` or `data` should be provided. If `data` is provided, `media_type` must be set to indicate the type of the data.
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/model-primitive
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct ModelPrimitive(pub(crate) foxglove::schemas::ModelPrimitive);
#[pymethods]
impl ModelPrimitive {
    #[new]
    #[pyo3(signature = (*, pose=None, scale=None, color=None, override_color=false, url="", media_type="", data=None) )]
    fn new(
        pose: Option<Pose>,
        scale: Option<Vector3>,
        color: Option<Color>,
        override_color: bool,
        url: &str,
        media_type: &str,
        data: Option<Bound<'_, PyBytes>>,
    ) -> Self {
        Self(foxglove::schemas::ModelPrimitive {
            pose: pose.map(Into::into),
            scale: scale.map(Into::into),
            color: color.map(Into::into),
            override_color,
            url: url.to_string(),
            media_type: media_type.to_string(),
            data: data
                .map(|x| Bytes::copy_from_slice(x.as_bytes()))
                .unwrap_or_default(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "ModelPrimitive(pose={:?}, scale={:?}, color={:?}, override_color={:?}, url={:?}, media_type={:?}, data={:?})",
            self.0.pose,
            self.0.scale,
            self.0.color,
            self.0.override_color,
            self.0.url,
            self.0.media_type,
            self.0.data,
        )
    }
    /// Returns the ModelPrimitive schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::ModelPrimitive::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the ModelPrimitive as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<ModelPrimitive> for foxglove::schemas::ModelPrimitive {
    fn from(value: ModelPrimitive) -> Self {
        value.0
    }
}

/// A field present within each element in a byte array of packed elements.
///
/// :param name: Name of the field
/// :param offset: Byte offset from start of data buffer
/// :param type: Type of data in the field. Integers are stored using little-endian byte order.
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/packed-element-field
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct PackedElementField(pub(crate) foxglove::schemas::PackedElementField);
#[pymethods]
impl PackedElementField {
    #[new]
    #[pyo3(signature = (*, name="", offset=0, r#type=PackedElementFieldNumericType::Unknown) )]
    fn new(name: &str, offset: u32, r#type: PackedElementFieldNumericType) -> Self {
        Self(foxglove::schemas::PackedElementField {
            name: name.to_string(),
            offset,
            r#type: r#type as i32,
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "PackedElementField(name={:?}, offset={:?}, r#type={:?})",
            self.0.name, self.0.offset, self.0.r#type,
        )
    }
    /// Returns the PackedElementField schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::PackedElementField::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the PackedElementField as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<PackedElementField> for foxglove::schemas::PackedElementField {
    fn from(value: PackedElementField) -> Self {
        value.0
    }
}

/// A point representing a position in 2D space
///
/// :param x: x coordinate position
/// :param y: y coordinate position
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/point2
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct Point2(pub(crate) foxglove::schemas::Point2);
#[pymethods]
impl Point2 {
    #[new]
    #[pyo3(signature = (*, x=0.0, y=0.0) )]
    fn new(x: f64, y: f64) -> Self {
        Self(foxglove::schemas::Point2 { x, y })
    }
    fn __repr__(&self) -> String {
        format!("Point2(x={:?}, y={:?})", self.0.x, self.0.y,)
    }
    /// Returns the Point2 schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::Point2::get_schema().unwrap().into()
    }
    /// Encodes the Point2 as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<Point2> for foxglove::schemas::Point2 {
    fn from(value: Point2) -> Self {
        value.0
    }
}

/// A point representing a position in 3D space
///
/// :param x: x coordinate position
/// :param y: y coordinate position
/// :param z: z coordinate position
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/point3
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct Point3(pub(crate) foxglove::schemas::Point3);
#[pymethods]
impl Point3 {
    #[new]
    #[pyo3(signature = (*, x=0.0, y=0.0, z=0.0) )]
    fn new(x: f64, y: f64, z: f64) -> Self {
        Self(foxglove::schemas::Point3 { x, y, z })
    }
    fn __repr__(&self) -> String {
        format!(
            "Point3(x={:?}, y={:?}, z={:?})",
            self.0.x, self.0.y, self.0.z,
        )
    }
    /// Returns the Point3 schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::Point3::get_schema().unwrap().into()
    }
    /// Encodes the Point3 as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<Point3> for foxglove::schemas::Point3 {
    fn from(value: Point3) -> Self {
        value.0
    }
}

/// A collection of N-dimensional points, which may contain additional fields with information like normals, intensity, etc.
///
/// :param timestamp: Timestamp of point cloud
/// :param frame_id: Frame of reference
/// :param pose: The origin of the point cloud relative to the frame of reference
/// :param point_stride: Number of bytes between points in the `data`
/// :param fields: Fields in `data`. At least 2 coordinate fields from `x`, `y`, and `z` are required for each point's position; `red`, `green`, `blue`, and `alpha` are optional for customizing each point's color.
/// :param data: Point data, interpreted using `fields`
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/point-cloud
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct PointCloud(pub(crate) foxglove::schemas::PointCloud);
#[pymethods]
impl PointCloud {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", pose=None, point_stride=0, fields=None, data=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        pose: Option<Pose>,
        point_stride: u32,
        fields: Option<Vec<PackedElementField>>,
        data: Option<Bound<'_, PyBytes>>,
    ) -> Self {
        Self(foxglove::schemas::PointCloud {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            pose: pose.map(Into::into),
            point_stride,
            fields: fields
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            data: data
                .map(|x| Bytes::copy_from_slice(x.as_bytes()))
                .unwrap_or_default(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "PointCloud(timestamp={:?}, frame_id={:?}, pose={:?}, point_stride={:?}, fields={:?}, data={:?})",
            self.0.timestamp,
            self.0.frame_id,
            self.0.pose,
            self.0.point_stride,
            self.0.fields,
            self.0.data,
        )
    }
    /// Returns the PointCloud schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::PointCloud::get_schema().unwrap().into()
    }
    /// Encodes the PointCloud as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<PointCloud> for foxglove::schemas::PointCloud {
    fn from(value: PointCloud) -> Self {
        value.0
    }
}

/// An array of points on a 2D image
///
/// :param timestamp: Timestamp of annotation
/// :param type: Type of points annotation to draw
/// :param points: Points in 2D image coordinates (pixels).
///     These coordinates use the top-left corner of the top-left pixel of the image as the origin.
/// :param outline_color: Outline color
/// :param outline_colors: Per-point colors, if `type` is `POINTS`, or per-segment stroke colors, if `type` is `LINE_LIST`, `LINE_STRIP` or `LINE_LOOP`.
/// :param fill_color: Fill color
/// :param thickness: Stroke thickness in pixels
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/points-annotation
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct PointsAnnotation(pub(crate) foxglove::schemas::PointsAnnotation);
#[pymethods]
impl PointsAnnotation {
    #[new]
    #[pyo3(signature = (*, timestamp=None, r#type=PointsAnnotationType::Unknown, points=None, outline_color=None, outline_colors=None, fill_color=None, thickness=0.0) )]
    fn new(
        timestamp: Option<Timestamp>,
        r#type: PointsAnnotationType,
        points: Option<Vec<Point2>>,
        outline_color: Option<Color>,
        outline_colors: Option<Vec<Color>>,
        fill_color: Option<Color>,
        thickness: f64,
    ) -> Self {
        Self(foxglove::schemas::PointsAnnotation {
            timestamp: timestamp.map(Into::into),
            r#type: r#type as i32,
            points: points
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            outline_color: outline_color.map(Into::into),
            outline_colors: outline_colors
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            fill_color: fill_color.map(Into::into),
            thickness,
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "PointsAnnotation(timestamp={:?}, r#type={:?}, points={:?}, outline_color={:?}, outline_colors={:?}, fill_color={:?}, thickness={:?})",
            self.0.timestamp,
            self.0.r#type,
            self.0.points,
            self.0.outline_color,
            self.0.outline_colors,
            self.0.fill_color,
            self.0.thickness,
        )
    }
    /// Returns the PointsAnnotation schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::PointsAnnotation::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the PointsAnnotation as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<PointsAnnotation> for foxglove::schemas::PointsAnnotation {
    fn from(value: PointsAnnotation) -> Self {
        value.0
    }
}

/// A position and orientation for an object or reference frame in 3D space
///
/// :param position: Point denoting position in 3D space
/// :param orientation: Quaternion denoting orientation in 3D space
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/pose
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct Pose(pub(crate) foxglove::schemas::Pose);
#[pymethods]
impl Pose {
    #[new]
    #[pyo3(signature = (*, position=None, orientation=None) )]
    fn new(position: Option<Vector3>, orientation: Option<Quaternion>) -> Self {
        Self(foxglove::schemas::Pose {
            position: position.map(Into::into),
            orientation: orientation.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "Pose(position={:?}, orientation={:?})",
            self.0.position, self.0.orientation,
        )
    }
    /// Returns the Pose schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::Pose::get_schema().unwrap().into()
    }
    /// Encodes the Pose as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<Pose> for foxglove::schemas::Pose {
    fn from(value: Pose) -> Self {
        value.0
    }
}

/// A timestamped pose for an object or reference frame in 3D space
///
/// :param timestamp: Timestamp of pose
/// :param frame_id: Frame of reference for pose position and orientation
/// :param pose: Pose in 3D space
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/pose-in-frame
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct PoseInFrame(pub(crate) foxglove::schemas::PoseInFrame);
#[pymethods]
impl PoseInFrame {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", pose=None) )]
    fn new(timestamp: Option<Timestamp>, frame_id: &str, pose: Option<Pose>) -> Self {
        Self(foxglove::schemas::PoseInFrame {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            pose: pose.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "PoseInFrame(timestamp={:?}, frame_id={:?}, pose={:?})",
            self.0.timestamp, self.0.frame_id, self.0.pose,
        )
    }
    /// Returns the PoseInFrame schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::PoseInFrame::get_schema().unwrap().into()
    }
    /// Encodes the PoseInFrame as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<PoseInFrame> for foxglove::schemas::PoseInFrame {
    fn from(value: PoseInFrame) -> Self {
        value.0
    }
}

/// An array of timestamped poses for an object or reference frame in 3D space
///
/// :param timestamp: Timestamp of pose
/// :param frame_id: Frame of reference for pose position and orientation
/// :param poses: Poses in 3D space
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/poses-in-frame
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct PosesInFrame(pub(crate) foxglove::schemas::PosesInFrame);
#[pymethods]
impl PosesInFrame {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", poses=None) )]
    fn new(timestamp: Option<Timestamp>, frame_id: &str, poses: Option<Vec<Pose>>) -> Self {
        Self(foxglove::schemas::PosesInFrame {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            poses: poses
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "PosesInFrame(timestamp={:?}, frame_id={:?}, poses={:?})",
            self.0.timestamp, self.0.frame_id, self.0.poses,
        )
    }
    /// Returns the PosesInFrame schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::PosesInFrame::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the PosesInFrame as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<PosesInFrame> for foxglove::schemas::PosesInFrame {
    fn from(value: PosesInFrame) -> Self {
        value.0
    }
}

/// A [quaternion](https://eater.net/quaternions) representing a rotation in 3D space
///
/// :param x: x value
/// :param y: y value
/// :param z: z value
/// :param w: w value
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/quaternion
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct Quaternion(pub(crate) foxglove::schemas::Quaternion);
#[pymethods]
impl Quaternion {
    #[new]
    #[pyo3(signature = (*, x=0.0, y=0.0, z=0.0, w=0.0) )]
    fn new(x: f64, y: f64, z: f64, w: f64) -> Self {
        Self(foxglove::schemas::Quaternion { x, y, z, w })
    }
    fn __repr__(&self) -> String {
        format!(
            "Quaternion(x={:?}, y={:?}, z={:?}, w={:?})",
            self.0.x, self.0.y, self.0.z, self.0.w,
        )
    }
    /// Returns the Quaternion schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::Quaternion::get_schema().unwrap().into()
    }
    /// Encodes the Quaternion as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<Quaternion> for foxglove::schemas::Quaternion {
    fn from(value: Quaternion) -> Self {
        value.0
    }
}

/// A single block of an audio bitstream
///
/// :param timestamp: Timestamp of the start of the audio block
/// :param data: Audio data. The samples in the data must be interleaved and little-endian
/// :param format: Audio format. Only 'pcm-s16' is currently supported
/// :param sample_rate: Sample rate in Hz
/// :param number_of_channels: Number of channels in the audio block
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/raw-audio
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct RawAudio(pub(crate) foxglove::schemas::RawAudio);
#[pymethods]
impl RawAudio {
    #[new]
    #[pyo3(signature = (*, timestamp=None, data=None, format="", sample_rate=0, number_of_channels=0) )]
    fn new(
        timestamp: Option<Timestamp>,
        data: Option<Bound<'_, PyBytes>>,
        format: &str,
        sample_rate: u32,
        number_of_channels: u32,
    ) -> Self {
        Self(foxglove::schemas::RawAudio {
            timestamp: timestamp.map(Into::into),
            data: data
                .map(|x| Bytes::copy_from_slice(x.as_bytes()))
                .unwrap_or_default(),
            format: format.to_string(),
            sample_rate,
            number_of_channels,
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "RawAudio(timestamp={:?}, data={:?}, format={:?}, sample_rate={:?}, number_of_channels={:?})",
            self.0.timestamp,
            self.0.data,
            self.0.format,
            self.0.sample_rate,
            self.0.number_of_channels,
        )
    }
    /// Returns the RawAudio schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::RawAudio::get_schema().unwrap().into()
    }
    /// Encodes the RawAudio as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<RawAudio> for foxglove::schemas::RawAudio {
    fn from(value: RawAudio) -> Self {
        value.0
    }
}

/// A raw image
///
/// :param timestamp: Timestamp of image
/// :param frame_id: Frame of reference for the image. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
/// :param width: Image width in pixels
/// :param height: Image height in pixels
/// :param encoding: Encoding of the raw image data. See the `data` field description for supported values.
/// :param step: Byte length of a single row. This is usually some multiple of `width` depending on the encoding, but can be greater to incorporate padding.
/// :param data: Raw image data.
///     
///     For each `encoding` value, the `data` field contains image pixel data serialized as follows:
///     
///     - `yuv422` or `uyvy`:
///       - Pixel colors are decomposed into `Y'UV <https://en.wikipedia.org/wiki/Y%E2%80%B2UV>`__ channels.
///       - Pixel channel values are represented as unsigned 8-bit integers.
///       - U and V values are shared between horizontal pairs of pixels. Each pair of output pixels is serialized as [U, Y1, V, Y2].
///       - `step` must be greater than or equal to `width` * 2.
///     - `yuv422_yuy2` or  `yuyv`:
///       - Pixel colors are decomposed into `Y'UV <https://en.wikipedia.org/wiki/Y%E2%80%B2UV>`__ channels.
///       - Pixel channel values are represented as unsigned 8-bit integers.
///       - U and V values are shared between horizontal pairs of pixels. Each pair of output pixels is encoded as [Y1, U, Y2, V].
///       - `step` must be greater than or equal to `width` * 2.
///     - `rgb8`:
///       - Pixel colors are decomposed into Red, Green, and Blue channels.
///       - Pixel channel values are represented as unsigned 8-bit integers.
///       - Each output pixel is serialized as [R, G, B].
///       - `step` must be greater than or equal to `width` * 3.
///     - `rgba8`:
///       - Pixel colors are decomposed into Red, Green, Blue, and Alpha channels.
///       - Pixel channel values are represented as unsigned 8-bit integers.
///       - Each output pixel is serialized as [R, G, B, Alpha].
///       - `step` must be greater than or equal to `width` * 4.
///     - `bgr8` or `8UC3`:
///       - Pixel colors are decomposed into Blue, Green, and Red channels.
///       - Pixel channel values are represented as unsigned 8-bit integers.
///       - Each output pixel is serialized as [B, G, R].
///       - `step` must be greater than or equal to `width` * 3.
///     - `bgra8`:
///       - Pixel colors are decomposed into Blue, Green, Red, and Alpha channels.
///       - Pixel channel values are represented as unsigned 8-bit integers.
///       - Each output pixel is encoded as [B, G, R, Alpha].
///       - `step` must be greater than or equal to `width` * 4.
///     - `32FC1`:
///       - Pixel brightness is represented as a single-channel, 32-bit little-endian IEEE 754 floating-point value, ranging from 0.0 (black) to 1.0 (white).
///       - `step` must be greater than or equal to `width` * 4.
///     - `bayer_rggb8`, `bayer_bggr8`, `bayer_rggb8`, `bayer_gbrg8`, or `bayer_grgb8`:
///       - Pixel colors are decomposed into Red, Blue and Green channels.
///       - Pixel channel values are represented as unsigned 8-bit integers, and serialized in a 2x2 bayer filter pattern.
///       - The order of the four letters after `bayer_` determine the layout, so for `bayer_wxyz8` the pattern is:
///       ```plaintext
///       w | x
///       - + -
///       y | z
///       ```
///       - `step` must be greater than or equal to `width`.
///     - `mono8` or `8UC1`:
///       - Pixel brightness is represented as unsigned 8-bit integers.
///       - `step` must be greater than or equal to `width`.
///     - `mono16` or `16UC1`:
///       - Pixel brightness is represented as 16-bit unsigned little-endian integers. Rendering of these values is controlled in `Image panel color mode settings <https://docs.foxglove.dev/docs/visualization/panels/image#general>`__.
///       - `step` must be greater than or equal to `width` * 2.
///     
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/raw-image
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct RawImage(pub(crate) foxglove::schemas::RawImage);
#[pymethods]
impl RawImage {
    #[new]
    #[pyo3(signature = (*, timestamp=None, frame_id="", width=0, height=0, encoding="", step=0, data=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        frame_id: &str,
        width: u32,
        height: u32,
        encoding: &str,
        step: u32,
        data: Option<Bound<'_, PyBytes>>,
    ) -> Self {
        Self(foxglove::schemas::RawImage {
            timestamp: timestamp.map(Into::into),
            frame_id: frame_id.to_string(),
            width,
            height,
            encoding: encoding.to_string(),
            step,
            data: data
                .map(|x| Bytes::copy_from_slice(x.as_bytes()))
                .unwrap_or_default(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "RawImage(timestamp={:?}, frame_id={:?}, width={:?}, height={:?}, encoding={:?}, step={:?}, data={:?})",
            self.0.timestamp,
            self.0.frame_id,
            self.0.width,
            self.0.height,
            self.0.encoding,
            self.0.step,
            self.0.data,
        )
    }
    /// Returns the RawImage schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::RawImage::get_schema().unwrap().into()
    }
    /// Encodes the RawImage as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<RawImage> for foxglove::schemas::RawImage {
    fn from(value: RawImage) -> Self {
        value.0
    }
}

/// A primitive representing a sphere or ellipsoid
///
/// :param pose: Position of the center of the sphere and orientation of the sphere
/// :param size: Size (diameter) of the sphere along each axis
/// :param color: Color of the sphere
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/sphere-primitive
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct SpherePrimitive(pub(crate) foxglove::schemas::SpherePrimitive);
#[pymethods]
impl SpherePrimitive {
    #[new]
    #[pyo3(signature = (*, pose=None, size=None, color=None) )]
    fn new(pose: Option<Pose>, size: Option<Vector3>, color: Option<Color>) -> Self {
        Self(foxglove::schemas::SpherePrimitive {
            pose: pose.map(Into::into),
            size: size.map(Into::into),
            color: color.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "SpherePrimitive(pose={:?}, size={:?}, color={:?})",
            self.0.pose, self.0.size, self.0.color,
        )
    }
    /// Returns the SpherePrimitive schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::SpherePrimitive::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the SpherePrimitive as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<SpherePrimitive> for foxglove::schemas::SpherePrimitive {
    fn from(value: SpherePrimitive) -> Self {
        value.0
    }
}

/// A text label on a 2D image
///
/// :param timestamp: Timestamp of annotation
/// :param position: Bottom-left origin of the text label in 2D image coordinates (pixels).
///     The coordinate uses the top-left corner of the top-left pixel of the image as the origin.
/// :param text: Text to display
/// :param font_size: Font size in pixels
/// :param text_color: Text color
/// :param background_color: Background fill color
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/text-annotation
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct TextAnnotation(pub(crate) foxglove::schemas::TextAnnotation);
#[pymethods]
impl TextAnnotation {
    #[new]
    #[pyo3(signature = (*, timestamp=None, position=None, text="", font_size=0.0, text_color=None, background_color=None) )]
    fn new(
        timestamp: Option<Timestamp>,
        position: Option<Point2>,
        text: &str,
        font_size: f64,
        text_color: Option<Color>,
        background_color: Option<Color>,
    ) -> Self {
        Self(foxglove::schemas::TextAnnotation {
            timestamp: timestamp.map(Into::into),
            position: position.map(Into::into),
            text: text.to_string(),
            font_size,
            text_color: text_color.map(Into::into),
            background_color: background_color.map(Into::into),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "TextAnnotation(timestamp={:?}, position={:?}, text={:?}, font_size={:?}, text_color={:?}, background_color={:?})",
            self.0.timestamp,
            self.0.position,
            self.0.text,
            self.0.font_size,
            self.0.text_color,
            self.0.background_color,
        )
    }
    /// Returns the TextAnnotation schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::TextAnnotation::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the TextAnnotation as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<TextAnnotation> for foxglove::schemas::TextAnnotation {
    fn from(value: TextAnnotation) -> Self {
        value.0
    }
}

/// A primitive representing a text label
///
/// :param pose: Position of the center of the text box and orientation of the text. Identity orientation means the text is oriented in the xy-plane and flows from -x to +x.
/// :param billboard: Whether the text should respect `pose.orientation` (false) or always face the camera (true)
/// :param font_size: Font size (height of one line of text)
/// :param scale_invariant: Indicates whether `font_size` is a fixed size in screen pixels (true), or specified in world coordinates and scales with distance from the camera (false)
/// :param color: Color of the text
/// :param text: Text
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/text-primitive
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct TextPrimitive(pub(crate) foxglove::schemas::TextPrimitive);
#[pymethods]
impl TextPrimitive {
    #[new]
    #[pyo3(signature = (*, pose=None, billboard=false, font_size=0.0, scale_invariant=false, color=None, text="") )]
    fn new(
        pose: Option<Pose>,
        billboard: bool,
        font_size: f64,
        scale_invariant: bool,
        color: Option<Color>,
        text: &str,
    ) -> Self {
        Self(foxglove::schemas::TextPrimitive {
            pose: pose.map(Into::into),
            billboard,
            font_size,
            scale_invariant,
            color: color.map(Into::into),
            text: text.to_string(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "TextPrimitive(pose={:?}, billboard={:?}, font_size={:?}, scale_invariant={:?}, color={:?}, text={:?})",
            self.0.pose,
            self.0.billboard,
            self.0.font_size,
            self.0.scale_invariant,
            self.0.color,
            self.0.text,
        )
    }
    /// Returns the TextPrimitive schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::TextPrimitive::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the TextPrimitive as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<TextPrimitive> for foxglove::schemas::TextPrimitive {
    fn from(value: TextPrimitive) -> Self {
        value.0
    }
}

/// A primitive representing a set of triangles or a surface tiled by triangles
///
/// :param pose: Origin of triangles relative to reference frame
/// :param points: Vertices to use for triangles, interpreted as a list of triples (0-1-2, 3-4-5, ...)
/// :param color: Solid color to use for the whole shape. One of `color` or `colors` must be provided.
/// :param colors: Per-vertex colors (if specified, must have the same length as `points`). One of `color` or `colors` must be provided.
/// :param indices: Indices into the `points` and `colors` attribute arrays, which can be used to avoid duplicating attribute data.
///     
///     If omitted or empty, indexing will not be used. This default behavior is equivalent to specifying [0, 1, ..., N-1] for the indices (where N is the number of `points` provided).
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/triangle-list-primitive
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct TriangleListPrimitive(pub(crate) foxglove::schemas::TriangleListPrimitive);
#[pymethods]
impl TriangleListPrimitive {
    #[new]
    #[pyo3(signature = (*, pose=None, points=None, color=None, colors=None, indices=None) )]
    fn new(
        pose: Option<Pose>,
        points: Option<Vec<Point3>>,
        color: Option<Color>,
        colors: Option<Vec<Color>>,
        indices: Option<Vec<u32>>,
    ) -> Self {
        Self(foxglove::schemas::TriangleListPrimitive {
            pose: pose.map(Into::into),
            points: points
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            color: color.map(Into::into),
            colors: colors
                .unwrap_or_default()
                .into_iter()
                .map(|x| x.into())
                .collect(),
            indices: indices.unwrap_or_default(),
        })
    }
    fn __repr__(&self) -> String {
        format!(
            "TriangleListPrimitive(pose={:?}, points={:?}, color={:?}, colors={:?}, indices={:?})",
            self.0.pose, self.0.points, self.0.color, self.0.colors, self.0.indices,
        )
    }
    /// Returns the TriangleListPrimitive schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::TriangleListPrimitive::get_schema()
            .unwrap()
            .into()
    }
    /// Encodes the TriangleListPrimitive as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<TriangleListPrimitive> for foxglove::schemas::TriangleListPrimitive {
    fn from(value: TriangleListPrimitive) -> Self {
        value.0
    }
}

/// A vector in 2D space that represents a direction only
///
/// :param x: x coordinate length
/// :param y: y coordinate length
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/vector2
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct Vector2(pub(crate) foxglove::schemas::Vector2);
#[pymethods]
impl Vector2 {
    #[new]
    #[pyo3(signature = (*, x=0.0, y=0.0) )]
    fn new(x: f64, y: f64) -> Self {
        Self(foxglove::schemas::Vector2 { x, y })
    }
    fn __repr__(&self) -> String {
        format!("Vector2(x={:?}, y={:?})", self.0.x, self.0.y,)
    }
    /// Returns the Vector2 schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::Vector2::get_schema().unwrap().into()
    }
    /// Encodes the Vector2 as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<Vector2> for foxglove::schemas::Vector2 {
    fn from(value: Vector2) -> Self {
        value.0
    }
}

/// A vector in 3D space that represents a direction only
///
/// :param x: x coordinate length
/// :param y: y coordinate length
/// :param z: z coordinate length
///
/// See https://docs.foxglove.dev/docs/visualization/message-schemas/vector3
#[pyclass(module = "foxglove.schemas")]
#[derive(Clone)]
pub(crate) struct Vector3(pub(crate) foxglove::schemas::Vector3);
#[pymethods]
impl Vector3 {
    #[new]
    #[pyo3(signature = (*, x=0.0, y=0.0, z=0.0) )]
    fn new(x: f64, y: f64, z: f64) -> Self {
        Self(foxglove::schemas::Vector3 { x, y, z })
    }
    fn __repr__(&self) -> String {
        format!(
            "Vector3(x={:?}, y={:?}, z={:?})",
            self.0.x, self.0.y, self.0.z,
        )
    }
    /// Returns the Vector3 schema.
    #[staticmethod]
    fn get_schema() -> PySchema {
        foxglove::schemas::Vector3::get_schema().unwrap().into()
    }
    /// Encodes the Vector3 as protobuf.
    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {
        PyBytes::new_with(
            py,
            self.0.encoded_len().expect("foxglove schemas provide len"),
            |mut b: &mut [u8]| {
                self.0
                    .encode(&mut b)
                    .expect("encoding len was provided above");
                Ok(())
            },
        )
        .expect("failed to allocate buffer for encoded message")
    }
}

impl From<Vector3> for foxglove::schemas::Vector3 {
    fn from(value: Vector3) -> Self {
        value.0
    }
}

pub fn register_submodule(parent_module: &Bound<'_, PyModule>) -> PyResult<()> {
    let module = PyModule::new(parent_module.py(), "schemas")?;

    module.add_class::<LinePrimitiveLineType>()?;
    module.add_class::<LogLevel>()?;
    module.add_class::<SceneEntityDeletionType>()?;
    module.add_class::<PackedElementFieldNumericType>()?;
    module.add_class::<PointsAnnotationType>()?;
    module.add_class::<LocationFixPositionCovarianceType>()?;
    module.add_class::<ArrowPrimitive>()?;
    module.add_class::<CameraCalibration>()?;
    module.add_class::<CircleAnnotation>()?;
    module.add_class::<Color>()?;
    module.add_class::<CompressedImage>()?;
    module.add_class::<CompressedVideo>()?;
    module.add_class::<CylinderPrimitive>()?;
    module.add_class::<CubePrimitive>()?;
    module.add_class::<Duration>()?;
    module.add_class::<FrameTransform>()?;
    module.add_class::<FrameTransforms>()?;
    module.add_class::<GeoJson>()?;
    module.add_class::<Grid>()?;
    module.add_class::<VoxelGrid>()?;
    module.add_class::<ImageAnnotations>()?;
    module.add_class::<KeyValuePair>()?;
    module.add_class::<LaserScan>()?;
    module.add_class::<LinePrimitive>()?;
    module.add_class::<LocationFix>()?;
    module.add_class::<LocationFixes>()?;
    module.add_class::<Log>()?;
    module.add_class::<SceneEntityDeletion>()?;
    module.add_class::<SceneEntity>()?;
    module.add_class::<SceneUpdate>()?;
    module.add_class::<ModelPrimitive>()?;
    module.add_class::<PackedElementField>()?;
    module.add_class::<Point2>()?;
    module.add_class::<Point3>()?;
    module.add_class::<PointCloud>()?;
    module.add_class::<PointsAnnotation>()?;
    module.add_class::<Pose>()?;
    module.add_class::<PoseInFrame>()?;
    module.add_class::<PosesInFrame>()?;
    module.add_class::<Quaternion>()?;
    module.add_class::<RawAudio>()?;
    module.add_class::<RawImage>()?;
    module.add_class::<SpherePrimitive>()?;
    module.add_class::<TextAnnotation>()?;
    module.add_class::<TextPrimitive>()?;
    module.add_class::<Timestamp>()?;
    module.add_class::<TriangleListPrimitive>()?;
    module.add_class::<Vector2>()?;
    module.add_class::<Vector3>()?;

    // Define as a package
    // https://github.com/PyO3/pyo3/issues/759
    let py = parent_module.py();
    py.import("sys")?
        .getattr("modules")?
        .set_item("foxglove._foxglove_py.schemas", &module)?;

    parent_module.add_submodule(&module)
}
