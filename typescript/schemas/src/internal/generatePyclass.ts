import {
  FoxgloveEnumSchema,
  FoxgloveMessageField,
  FoxgloveMessageSchema,
  FoxglovePrimitive,
  FoxgloveSchema,
} from "./types";

/**
 * Generate the module header for schema pyclass definitions.
 */
export function generateSchemaPrelude(): string {
  const docs = [
    `//! Definitions for well-known Foxglove schemas`,
    `//! Generated by https://github.com/foxglove/foxglove-sdk`,
    // Accept any number of arguments for Python constructors
    `#![allow(clippy::too_many_arguments)]`,
    // Match Foxglove enum conventions elsewhere (shared prefix)
    `#![allow(clippy::enum_variant_names)]`,
    // Allow capitalized single-letter enum variants
    `#![allow(non_snake_case)]`,
  ];

  const imports = [
    "use crate::PySchema;",
    "use crate::schemas_wkt::{Duration, Timestamp};",
    "use bytes::Bytes;",
    "use foxglove::Encode;",
    "use pyo3::prelude::*;",
    "use pyo3::types::PyBytes;",
  ];

  const outputSections = [docs.join("\n"), imports.join("\n")];

  return outputSections.join("\n") + "\n\n";
}

/**
 * Generate a `pyclass`-annotated struct or enum definition for the given schema.
 */
export function generatePyclass(schema: FoxgloveSchema): string {
  if (!shouldGenerateSchemaClass(schema)) {
    return "";
  }
  return isMessageSchema(schema) ? generateMessageClass(schema) : generateEnumClass(schema);
}

/**
 * Generate a .pyi stub for the given schemas.
 */
export function generatePySchemaStub(schemas: FoxgloveSchema[]): string {
  const header =
    [
      "# Generated by https://github.com/foxglove/foxglove-sdk",
      "from enum import Enum",
      "from typing import Union",
      "",
      "from . import Schema",
      // Use "from mod import X as X" syntax to explicitly re-export.
      "from .schemas_wkt import Duration as Duration",
      "from .schemas_wkt import Timestamp as Timestamp",
    ].join("\n") + "\n";

  const enums = schemas
    .filter((schema) => schema.type === "enum")
    .filter(shouldGenerateSchemaClass)
    .map((schema) => {
      const name = enumName(schema);
      const doc = ['    """', `    ${schema.description}`, '    """'];
      const values = schema.values.map((value) => {
        return `    ${constantToTitleCase(value.name)} = ${value.value}`;
      });
      return {
        name,
        source: [`class ${name}(Enum):`, ...doc, ...values].join("\n") + "\n\n",
      };
    });

  const allSchemas: string[] = [];

  const classes = schemas
    .filter(isMessageSchema)
    .filter(shouldGenerateSchemaClass)
    .map((schema) => {
      const name = structName(schema.name);
      allSchemas.push(name);
      const doc = ['    """', `    ${schema.description}`, '    """'];
      const params = schema.fields
        .map((field) => {
          return `        ${field.name}: ${pythonCtorType(field)} = ${pythonDefaultValue(field)}`;
        })
        .join(",\n");

      return {
        name,
        source:
          [
            `class ${name}:`,
            ...doc,
            `    def __init__(`,
            "        self,",
            "        *,",
            params,
            `    ) -> None: ...`,
            `    @staticmethod`,
            `    def get_schema() -> Schema:`,
            `        """Returns the ${name} schema"""`,
            `        ...`,
            `    def encode(self) -> bytes:`,
            `        """Encodes the ${name}."""`,
            `        ...`,
          ].join("\n") + "\n\n",
      };
    });

  // Enums come first to provide default values for constructor parameters. Otherwise, sort by name.
  const enumSources = enums
    .sort((a, b) => a.name.localeCompare(b.name))
    .map(({ source }) => source);
  const classSources = classes
    .sort((a, b) => a.name.localeCompare(b.name))
    .map(({ source }) => source);

  const enumMarker = "#\n# Enums\n#\n";
  const classMarker = "#\n# Classes\n#\n";

  const typeUnion = `\nFoxgloveSchema = Union[${allSchemas.join(", ")}];\n`;

  return [header, enumMarker, ...enumSources, classMarker, ...classSources, typeUnion].join("\n");
}

/**
 * Generate a module __init__ file re-exporting all schemas to the public API.
 */
export function generatePySchemaModule(schemas: FoxgloveSchema[]): string {
  const allSchemas = schemas
    .filter(isMessageSchema)
    .map((schema) => pyClassName(schema))
    .sort();
  const classNames = schemas.map((schema) => pyClassName(schema)).sort();
  const headers = [
    `"""`,
    `This module contains the definitions of the well-known Foxglove schemas for logging.`,
    "",
    "Log messages to a corresponding channel type from :py:mod:`foxglove.channels`.",
    "",
    "Note that the schema classes are currently immutable and do not expose",
    "getters and setters for their fields. This is a limitation we plan to address in the future.",
    `"""`,
    "# Generated by https://github.com/foxglove/foxglove-sdk",
    "",
    "from typing import Union",
  ];
  const imports = classNames.map((name) => `from foxglove._foxglove_py.schemas import ${name}`);
  const exports = [
    "__all__ = [",
    "    'FoxgloveSchema',",
    ...classNames.map((name) => `    "${name}",`),
    "]",
  ];
  const alias = `FoxgloveSchema = Union[${allSchemas.join(", ")}];\n`;

  return [...headers, ...imports, alias, ...exports, ""].join("\n");
}

/**
 * Format a string as a Rust doc comment, splitting on newlines and prefixing each line with `///`.
 */
function rustDoc(str: string): string {
  return str
    .split("\n")
    .map((line) => `/// ${line}`)
    .join("\n");
}

/**
 * Convert markdown links to RST format: [text](url) becomes `text <url>`__
 */
function convertMarkdownLinksToRst(text: string): string {
  return text.replace(/\[(?<text>[^\]]+)\]\((?<url>[^)]+)\)/g, "`$<text> <$<url>>`__");
}

/**
 * Generate a :param doc comment for a field.
 *
 * The returned string may be multi-line. This converts markdown code blocks and links to RST inside
 * extended descriptions.
 */
function pythonParamDoc(field: FoxgloveMessageField): string {
  const lines = field.description.split("\n");
  const [firstLine, ...rest] = lines;
  const output: string[] = [];
  if (firstLine == undefined) {
    return "";
  }

  output.push(`:param ${field.name}: ${firstLine}`);
  if (rest.length === 0) {
    return output.join("\n");
  }

  let inCodeBlock = false;
  for (const line of rest) {
    if (line.startsWith("```")) {
      if (!inCodeBlock) {
        // Start an RST code block, which requires a following blank line
        output.push("    ::");
        output.push("");
      }
      inCodeBlock = !inCodeBlock;
      continue;
    }

    const indent = " ".repeat(inCodeBlock ? 8 : 4);
    const rst = inCodeBlock ? line : convertMarkdownLinksToRst(line);
    output.push(indent + rst);
  }

  return output.join("\n");
}

function generateMessageClass(schema: FoxgloveMessageSchema): string {
  const className = structName(schema.name);
  const struct = [
    rustDoc(schema.description),
    `///`,
    ...schema.fields.map((field) => rustDoc(pythonParamDoc(field))),
    `///`,
    `/// See https://docs.foxglove.dev/docs/visualization/message-schemas/${constantToKebabCase(className)}`,
    `#[pyclass(module = "foxglove.schemas")]`,
    `#[derive(Clone)]`,
    `pub(crate) struct ${className}(pub(crate) foxglove::schemas::${className});`,
  ];

  function fieldValue(field: FoxgloveMessageField): string {
    if (field.type.type === "primitive" && field.type.name === "bytes") {
      // Special case — this is an `Option<Bound<'_, PyBytes>>`; see `rustOutputType`
      return `${field.name}.map(|x| Bytes::copy_from_slice(x.as_bytes())).unwrap_or_default()`;
    }
    switch (field.type.type) {
      case "primitive":
        if (field.array != undefined) {
          if (field.type.name === "string") {
            return `${safeRustName(field.name)}.unwrap_or_default().into_iter().map(String::from).collect()`;
          }
          return `${safeRustName(field.name)}.unwrap_or_default()`;
        }
        if (field.type.name === "string") {
          return `${safeRustName(field.name)}.to_string()`;
        }
        return safeRustName(field.name);
      case "nested":
        if (field.array != undefined) {
          return `${safeRustName(field.name)}.unwrap_or_default().into_iter().map(|x| x.into()).collect()`;
        }
        return `${safeRustName(field.name)}.map(Into::into)`;
      case "enum":
        if (field.array != undefined) {
          return `${safeRustName(field.name)}.unwrap_or_default().into_iter().map(|x| x as i32).collect()`;
        }
        return `${safeRustName(field.name)} as i32`;
    }
  }

  function fieldAssignment(field: FoxgloveMessageField): string {
    const name = protoName(field.name);
    const value = fieldValue(field);
    if (name === value) {
      return name;
    }
    return `${name}: ${value}`;
  }

  const schemaFields = Array.from(schema.fields).map((field) => ({
    fieldName: safeRustName(field.name),
    argName: safeRustName(field.name),
    field,
  }));

  const signature = schemaFields
    .map(({ argName, field }) => `${argName}=${rustDefaultValue(field)}`)
    .join(", ");

  const impl = [
    `#[pymethods]`,
    `impl ${className} {`,
    `    #[new]`,
    `    #[pyo3(signature = (*, ${signature}) )]`,
    `    fn new(`,
    ...schemaFields.map(({ argName, field }) => `        ${argName}: ${rustOutputType(field)},`),
    `    ) -> Self {`,
    `        Self(foxglove::schemas::${className} {`,
    schemaFields.map(({ field }) => `            ${fieldAssignment(field)},`).join("\n"),
    `        })`,
    `    }`,
    `    fn __repr__(&self) -> String {`,
    `        format!(`,
    `            "${className}(${schemaFields.map(({ argName }) => `${argName}={:?}`).join(", ")})",`,
    schemaFields.map(({ fieldName }) => `            self.0.${protoName(fieldName)},`).join("\n"),
    `        )`,
    `    }`,
    `    /// Returns the ${className} schema.`,
    `    #[staticmethod]`,
    `    fn get_schema() -> PySchema {`,
    `        foxglove::schemas::${className}::get_schema().unwrap().into()`,
    `    }`,
    `    /// Encodes the ${className} as protobuf.`,
    `    fn encode<'a>(&self, py: Python<'a>) -> Bound<'a, PyBytes> {`,
    `        PyBytes::new_with(py, self.0.encoded_len().expect("foxglove schemas provide len"), |mut b: &mut[u8]| {`,
    `            self.0.encode(&mut b).expect("encoding len was provided above");`,
    `            Ok(())`,
    `        }).expect("failed to allocate buffer for encoded message")`,
    `    }`,
    `}\n\n`,
  ];

  const fromTrait = [
    `impl From<${structName(schema.name)}> for foxglove::schemas::${structName(schema.name)} {`,
    `    fn from(value: ${structName(schema.name)}) -> Self {`,
    `        value.0`,
    `    }`,
    `}\n\n`,
  ];

  return [...struct, ...impl, ...fromTrait].join("\n");
}

function generateEnumClass(schema: FoxgloveEnumSchema): string {
  const enumLines = [
    rustDoc(schema.description),
    `#[pyclass(eq, eq_int, module = "foxglove.schemas")]`,
    `#[derive(PartialEq, Clone)]`,
    `pub(crate) enum ${enumName(schema)} {`,
    ...schema.values.map((value) => `    ${constantToTitleCase(value.name)} = ${value.value},`),
    "}\n\n",
  ];

  return enumLines.join("\n");
}

/**
 * For enums with parent schemas, prepend the parent schema name to the enum name,
 * removing duplicated prefixes.
 */
function enumName(schema: FoxgloveEnumSchema): string {
  const name = schema.name.replace(new RegExp("^" + schema.parentSchemaName), "");
  return `${schema.parentSchemaName}${name}`;
}

/**
 * Deal with reserved keywords in identifiers
 */
function safeRustName(name: string): string {
  if (name === "type") {
    return "r#type";
  }
  return name;
}

/**
 * A schema is either a message schema or an enum.
 */
function isMessageSchema(schema: FoxgloveSchema): schema is FoxgloveMessageSchema {
  return schema.type === "message";
}

/**
 * Get the rust type for a field.
 * Types are assumed to be owned, and wrapped in a `Vec` if the field is an array.
 * Nested types are optional.
 */
function rustOutputType(field: FoxgloveMessageField): string {
  const isVec = field.array != undefined;
  const isOpt = field.type.type === "nested";
  let type: string;
  switch (field.type.type) {
    case "primitive":
      switch (field.type.name) {
        case "string":
          type = "&str";
          break;
        case "float64":
          type = "f64";
          break;
        case "int32":
          type = "i32";
          break;
        case "uint32":
          type = "u32";
          break;
        case "boolean":
          type = "bool";
          break;
        case "bytes":
          // Special case: we don't take a Vec<u8> directly because pyo3 will iterate the vec and
          // copy each element https://github.com/PyO3/pyo3/issues/2888
          return "Option<Bound<'_, PyBytes>>";
      }
      break;
    case "nested":
      type = field.type.schema.name;
      break;
    case "enum":
      type = enumName(field.type.enum);
      break;
  }
  if (isVec) {
    return `Option<Vec<${type}>>`;
  } else if (isOpt) {
    return `Option<${type}>`;
  }
  return type;
}

/**
 * Get the Python type for a constructor parameter.
 * All types are optional.
 */
function pythonCtorType(field: FoxgloveMessageField): string {
  const isVec = field.array != undefined;
  const isOpt = field.type.type === "nested";
  let type: string;
  switch (field.type.type) {
    case "primitive":
      type = pythonType(field.type.name);
      break;
    case "nested":
      type = field.type.schema.name;
      break;
    case "enum":
      type = enumName(field.type.enum);
      break;
  }
  if (isVec) {
    return `list[${type}] | None`;
  } else if (isOpt) {
    return `${type} | None`;
  }
  return type;
}

/**
 * Get the Python default for a constructor parameter
 */
function pythonDefaultValue(field: FoxgloveMessageField): string {
  if (field.array != undefined) {
    return "None";
  }
  switch (field.type.type) {
    case "primitive":
      switch (field.type.name) {
        case "string":
          return `""`;
        case "float64":
          return "0.0";
        case "int32":
        case "uint32":
          return "0";
        case "boolean":
          return "False";
        case "bytes":
          return 'b""';
      }
    // exhaustive check above
    // eslint-disable-next-line no-fallthrough
    case "nested":
      return "None";
    case "enum": {
      const value = constantToTitleCase(field.type.enum.values[0]!.name);
      return `${enumName(field.type.enum)}.${value}`;
    }
  }
}

/**
 * Get the Rust default for a field; used in pyo3 constructor signatures.
 */
function rustDefaultValue(field: FoxgloveMessageField): string {
  if (field.type.type === "primitive" && field.type.name === "bytes") {
    // Special case — this is an `Option<Bound<'_, PyBytes>>`; see `rustOutputType`
    return "None";
  }
  if (field.array != undefined) {
    return "None";
  }
  switch (field.type.type) {
    case "primitive":
      switch (field.type.name) {
        case "string":
          return `""`;
        case "float64":
          return "0.0";
        case "int32":
        case "uint32":
          return "0";
        case "boolean":
          return "false";
        case "bytes":
          return "vec![]";
      }
    // exhaustive check above
    // eslint-disable-next-line no-fallthrough
    case "nested":
      return "None";
    case "enum": {
      const value = constantToTitleCase(field.type.enum.values[0]!.name);
      return `${enumName(field.type.enum)}::${value}`;
    }
  }
}

/**
 * Map Foxglove primitive types to Python primitives.
 */
function pythonType(foxglovePrimitive: FoxglovePrimitive): string {
  switch (foxglovePrimitive) {
    case "string":
      return "str";
    case "float64":
      return "float";
    case "int32":
    case "uint32":
      return "int";
    case "boolean":
      return "bool";
    case "bytes":
      return "bytes";
  }
}

function protoName(name: string): string {
  if (/^[A-Z]$/.exec(name)) {
    // Schemas may include single-letter capitals; generated proto structs use lowercase
    return name.toLowerCase();
  }
  return safeRustName(name);
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function constantToTitleCase(str: string): string {
  return str
    .split("_")
    .map((word) => word.toLowerCase())
    .map(capitalize)
    .join("");
}

function constantToKebabCase(name: string): string {
  return name
    .replace(/^[A-Z]/, (match) => match.toLowerCase())
    .replace(/([A-Z])/g, (match) => `-${match.toLowerCase()}`);
}

function structName(name: string): string {
  // Match special case handling in protobuf gen
  if (name === "GeoJSON") {
    return "GeoJson";
  }
  return name;
}

/**
 * Generate a rust function to register the schemas in a submodule.
 * https://pyo3.rs/v0.23.4/module.html
 */
export function generateSchemaModuleRegistration(schemas: FoxgloveSchema[]): string {
  return `
pub fn register_submodule(parent_module: &Bound<'_, PyModule>) -> PyResult<()> {
    let module = PyModule::new(parent_module.py(), "schemas")?;

    ${schemas.map((schema) => `module.add_class::<${pyClassName(schema)}>()?;`).join("\n    ")}

    // Define as a package
    // https://github.com/PyO3/pyo3/issues/759
    let py = parent_module.py();
    py.import("sys")?
        .getattr("modules")?
        .set_item("foxglove._foxglove_py.schemas", &module)?;

    parent_module.add_submodule(&module)
}
`;
}

/**
 * Python SDK uses custom implementations for Time and Duration via schemas_wkt, so we don't
 * auto-generate implementations or stubs. These match the `{ sec, nsec }` schema definition but
 * provide additional conversions and factory methods.
 */
function shouldGenerateSchemaClass(schema: FoxgloveSchema): boolean {
  return schema.name !== "Timestamp" && schema.name !== "Duration";
}

/**
 * Because the SDK uses custom schema implementations, we don't yet generate channels for them.
 */
function shouldGenerateChannelClass(schema: FoxgloveMessageSchema): boolean {
  return schema.name !== "Timestamp" && schema.name !== "Duration";
}

/**
 * Generate a rust function to register the channels in a submodule.
 * https://pyo3.rs/v0.23.4/module.html
 */
function generateChannelModuleRegistration(schemas: FoxgloveMessageSchema[]): string {
  return `
pub fn register_submodule(parent_module: &Bound<'_, PyModule>) -> PyResult<()> {
    let module = PyModule::new(parent_module.py(), "channels")?;

    ${schemas.map((schema) => `module.add_class::<${structName(schema.name)}Channel>()?;`).join("\n    ")}

    // Define as a package
    // https://github.com/PyO3/pyo3/issues/759
    let py = parent_module.py();
    py.import("sys")?
        .getattr("modules")?
        .set_item("foxglove._foxglove_py.channels", &module)?;

    parent_module.add_submodule(&module)
}
`;
}

function pyClassName(schema: FoxgloveSchema): string {
  return isMessageSchema(schema) ? structName(schema.name) : enumName(schema);
}

/**
 * Generate a concrete `pyclass`-annotated Channel struct for each message schema, since generics
 * can't be exported directly to Python.
 */
export function generateChannelClasses(messageSchemas: FoxgloveMessageSchema[]): string {
  const schemas = messageSchemas.filter(shouldGenerateChannelClass);
  const header = [
    `//! Typed channels for logging Foxglove schemas`,
    `//! Generated by https://github.com/foxglove/foxglove-sdk`,
  ].join("\n");

  const imports = [
    `use crate::{PyContext, PySchema};`,
    `use foxglove::{Channel, ChannelBuilder, PartialMetadata, SinkId};`,
    `use pyo3::prelude::*;`,
    `use pyo3::types::PyDict;`,
    `use super::schemas;`,
    `use std::collections::BTreeMap;`,
    `use std::num::NonZero;`,
  ].join("\n");

  const channelModuleRegistration = generateChannelModuleRegistration(schemas);

  const classes = schemas.map((schema) => {
    const schemaClass = structName(schema.name);
    const channelClass = `${schemaClass}Channel`;
    return `
/// A channel for logging :py:class:\`foxglove.schemas.${schemaClass}\` messages.
#[pyclass(module = "foxglove.channels")]
struct ${channelClass}(Channel<foxglove::schemas::${schemaClass}>);

#[pymethods]
impl ${channelClass} {
    /// Create a new channel.
    ///
    /// :param topic: The topic to log messages to. You should choose a unique topic name per channel.
    /// :param metadata: A dictionary of key/value strings to add to the channel.
    ///     A type error is raised if any key or value is not a string.
    #[new]
    #[pyo3(signature = (topic, *, metadata=None, context=None))]
    fn new(topic: &str, metadata: Option<BTreeMap<String, String>>, context: Option<&PyContext>) -> Self {
        let builder = ChannelBuilder::new(topic).metadata(metadata.unwrap_or_default());
        let builder = if let Some(context) = context {
            builder.context(&context.0.clone())
        } else {
            builder
        };
        let base = builder.build();
        Self(base)
    }

    /// The unique ID of the channel.
    fn id(&self) -> u64 {
        self.0.id().into()
    }

    /// The topic name of the channel.
    fn topic(&self) -> &str {
        self.0.topic()
    }

    /// The message encoding for the channel.
    #[getter]
    fn message_encoding(&self) -> &str {
        self.0.message_encoding()
    }

    /// Returns a copy of the channel's metadata.
    ///
    /// Note that changes made to the returned dictionary will not be applied to
    /// the channel's metadata.
    fn metadata(&self, py: Python<'_>) -> PyResult<PyObject> {
        let dict = PyDict::new(py);
        for (key, value) in self.0.metadata() {
            dict.set_item(key, value)?;
        }
        Ok(dict.into())
    }

    /// Returns a copy of the channel's schema.
    ///
    /// Note that changes made to the returned object will not be applied to
    /// the channel's schema.
    fn schema(&self) -> Option<PySchema> {
        self.0.schema().cloned().map(PySchema::from)
    }

    /// The name of the schema for the channel.
    fn schema_name(&self) -> Option<&str> {
        Some(self.0.schema()?.name.as_str())
    }

    /// Returns true if at least one sink is subscribed to this channel.
    fn has_sinks(&self) -> bool {
        self.0.has_sinks()
    }

    /// Close the channel.
    ///
    /// You can use this to explicitly unadvertise the channel to sinks that subscribe to
    /// channels dynamically, such as the :py:class:\`foxglove.websocket.WebSocketServer\`.
    ///
    /// Attempts to log on a closed channel will elicit a throttled warning message.
    fn close(&mut self) {
        self.0.close();
    }

    /// Log a :py:class:\`foxglove.schemas.${schemaClass}\` message to the channel.
    ///
    /// :param msg: The message to log.
    /// :param log_time: The log time is the time, as nanoseconds from the unix epoch, that the
    ///     message was recorded. Usually this is the time log() is called. If omitted, the
    ///     current time is used.
    /// :param sink_id: The ID of the sink to log to. If omitted, the message is logged to all sinks.
    #[pyo3(signature = (msg, *, log_time=None, sink_id=None))]
    fn log(
        &self,
        msg: &schemas::${schemaClass},
        log_time: Option<u64>,
        sink_id: Option<u64>,
    ) {
        let metadata = PartialMetadata{ log_time };
        let sink_id = sink_id.and_then(NonZero::new).map(SinkId::new);

        self.0.log_with_meta_to_sink(&msg.0, metadata, sink_id);
    }

    fn __repr__(&self) -> String {
        format!("${channelClass}(id={}, topic='{}')", self.id(), self.topic()).to_string()
    }
}
`;
  });

  return [header, imports, channelModuleRegistration, ...classes].join("\n\n");
}

/**
 * Generate a .pyi stub for the given schema channels.
 */
export function generatePyChannelStub(messageSchemas: FoxgloveMessageSchema[]): string {
  const header = "# Generated by https://github.com/foxglove/foxglove-sdk";
  const schemas = messageSchemas.filter(shouldGenerateChannelClass);

  const imports = [
    "from . import Context, Schema",
    ...schemas.map((schema) => `from .schemas import ${structName(schema.name)}`),
  ];

  const classes = schemas.map((schema) => {
    const schemaClass = structName(schema.name);
    const channelClass = `${schemaClass}Channel`;
    const doc = [
      `    """`,
      `    A channel for logging ${schemaClass} messages`,
      ``,
      `    You should choose a unique topic name per channel.`,
      `    """`,
    ];

    return {
      name: channelClass,
      source: [
        `class ${channelClass}:`,
        ...doc,
        `    def __init__(`,
        `        self,`,
        `        topic: str,`,
        `        *,`,
        `        metadata: dict[str, str] | None = None,`,
        `        context: Context | None = None,`,
        `    ) -> None: ...\n`,
        `    def id(self) -> int:`,
        `        """The unique ID of the channel."""`,
        `        ...`,
        `    def topic(self) -> str:`,
        `        """The topic name of the channel."""`,
        `        ...`,
        `    @property`,
        `    def message_encoding(self) -> str:`,
        `        """The message encoding for the channel"""`,
        `        ...`,
        `    def metadata(self) -> dict[str, str]:`,
        `        """`,
        `        Returns a copy of the channel's metadata.`,
        ``,
        `        Note that changes made to the returned dictionary will not be applied to`,
        `        the channel's metadata.`,
        `        """`,
        `        ...`,
        `    def schema(self) -> Schema | None:`,
        `        """`,
        `        Returns a copy of the channel's schema.`,
        ``,
        `        Note that changes made to the returned object will not be applied to`,
        `        the channel's schema.`,
        `        """`,
        `        ...`,
        `    def schema_name(self) -> str | None:`,
        `        """The name of the schema for the channel."""`,
        `        ...`,
        `    def has_sinks(self) -> bool:`,
        `        """Returns true if at least one sink is subscribed to this channel"""`,
        `        ...`,
        `    def close(self) -> None:`,
        `        """Close the channel."""`,
        `        ...`,
        `    def log(`,
        `        self,`,
        `        message: "${schemaClass}",`,
        `        *,`,
        `        log_time: int | None = None,`,
        `        sink_id: int | None = None,`,
        `    ) -> None:`,
        `        """Log a Foxglove ${schemaClass} message on the channel."""`,
        `        ...`,
      ].join("\n"),
    };
  });

  const definitions = [...classes]
    .sort((a, b) => a.name.localeCompare(b.name))
    .map(({ source }) => source);

  return [header, ...imports, ...definitions].join("\n");
}

/**
 * Generate a module __init__ file re-exporting all channels to the public API.
 */
export function generatePyChannelModule(schemas: FoxgloveMessageSchema[]): string {
  const headers = [
    `"""`,
    `This module defines channels to easily log messages conforming to well-known Foxglove schemas.`,
    ``,
    "See the :py:mod:`foxglove.schemas` module for available definitions.",
    `"""`,
    "# Generated by https://github.com/foxglove/foxglove-sdk",
  ];
  const classNames = schemas
    .filter(shouldGenerateChannelClass)
    .map((schema) => `${structName(schema.name)}Channel`)
    .sort();
  const imports = classNames.map((name) => `from foxglove._foxglove_py.channels import ${name}`);
  const exports = ["__all__ = [", ...classNames.map((name) => `    "${name}",`), "]"];

  return [...headers, ...imports, ...exports].join("\n") + "\n";
}
