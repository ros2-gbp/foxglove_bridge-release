import { FoxgloveMessageSchema, FoxglovePrimitive } from "./types";

function primitiveToJsonSchema(type: FoxglovePrimitive) {
  switch (type) {
    case "bytes":
      return { type: "string", contentEncoding: "base64" };
    case "string":
      return { type: "string" };
    case "boolean":
      return { type: "boolean" };
    case "float64":
      return { type: "number" };
    case "int32":
      return { type: "integer" };
    case "uint32":
      return { type: "integer", minimum: 0 };
  }
}

/**
 * Applies additional constraints on time and duration types.
 */
function timeOrDurationToJsonSchema(schema: FoxgloveMessageSchema) {
  if (schema.name === "Timestamp") {
    return {
      type: "object",
      title: "time",
      properties: {
        sec: { type: "integer", minimum: 0 },
        nsec: { type: "integer", minimum: 0, maximum: 999_999_999 },
      },
    };
  }
  if (schema.name === "Duration") {
    return {
      type: "object",
      title: "duration",
      properties: {
        sec: { type: "integer" },
        nsec: { type: "integer", minimum: 0, maximum: 999_999_999 },
      },
    };
  }
  throw new Error(`Unknown time or duration schema: ${schema.name}`);
}

export function generateJsonSchema(schema: FoxgloveMessageSchema): Record<string, unknown> {
  const properties: Record<string, unknown> = {};
  for (const field of schema.fields) {
    let fieldType: Record<string, unknown>;
    switch (field.type.type) {
      case "primitive":
        fieldType = primitiveToJsonSchema(field.type.name);
        break;
      case "nested":
        if (field.type.schema.name === "Timestamp" || field.type.schema.name === "Duration") {
          fieldType = timeOrDurationToJsonSchema(field.type.schema);
        } else {
          fieldType = generateJsonSchema(field.type.schema);
        }
        delete fieldType.$comment;
        break;
      case "enum":
        fieldType = {
          title: `foxglove.${field.type.enum.name}`,
          description: field.description,
          oneOf: field.type.enum.values.map(({ name, value, description }) => ({
            title: name,
            const: value,
            description,
          })),
        };
        break;
    }
    if (typeof field.array === "number") {
      fieldType = {
        type: "array",
        items: fieldType,
        minItems: field.array,
        maxItems: field.array,
      };
    } else if (field.array === true) {
      fieldType = { type: "array", items: fieldType };
    }
    fieldType.description = field.description;
    properties[field.name] = fieldType;
  }

  return {
    title: `foxglove.${schema.name}`,
    description: schema.description,
    $comment: "Generated by https://github.com/foxglove/foxglove-sdk",
    type: "object",
    properties,
  };
}
